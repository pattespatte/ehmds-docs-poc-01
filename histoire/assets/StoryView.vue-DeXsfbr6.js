const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/angular-html-BYG42TJr.js","assets/html-GC16tDh9.js","assets/javascript-BsAkV7mL.js","assets/css-BtVcDqlU.js","assets/angular-ts-BftcHvZ6.js","assets/scss-Dq-LbI_c.js","assets/apl-CGZawg-A.js","assets/xml-BMzZeaqs.js","assets/java-BfXh-0uJ.js","assets/json-TjWBGEk1.js","assets/astro-BxdWOZvM.js","assets/typescript-CP6ECzON.js","assets/postcss-kj1IbjVd.js","assets/tsx-CmGGo4Hm.js","assets/blade-BbH7YAUi.js","assets/html-derivative-HU9p64q4.js","assets/sql-DzUuSofg.js","assets/bsl-DwPS0BId.js","assets/sdbl-BBUhycGU.js","assets/cairo-BtYx2aM5.js","assets/python-CrdIx4PZ.js","assets/cobol-B8r1pfPr.js","assets/coffee-XLjtuEYs.js","assets/cpp-zh2ePAE_.js","assets/regexp-BxWeO75u.js","assets/glsl-CGsiYPcu.js","assets/c-C4VtT7JA.js","assets/crystal-BqBRy7Ec.js","assets/shellscript-CQ8MXh-D.js","assets/edge-CnHxQ_FD.js","assets/elixir-B_LIBv5J.js","assets/elm-BlO7pcFp.js","assets/erb-D0-JOe_j.js","assets/ruby-CPCASdTw.js","assets/haml-DrIklt7F.js","assets/graphql-CwmtR1ib.js","assets/jsx-BPmvoin2.js","assets/lua-BVbbqwZC.js","assets/yaml-B_vW5iTY.js","assets/erlang-Ch5kuXHm.js","assets/markdown-F_EULe_G.js","assets/fortran-fixed-form-CpmOyvS5.js","assets/fortran-free-form-5X94ETMi.js","assets/fsharp-5vtGqRR9.js","assets/gdresource-B5TLWiFO.js","assets/gdshader-BEzE4j_3.js","assets/gdscript-CNW3Aj-d.js","assets/git-commit-PP9xCApN.js","assets/diff-BEdzuHlE.js","assets/git-rebase-D-XQSvDj.js","assets/glimmer-js-h2QNNiD7.js","assets/glimmer-ts-Bk3uX6Ae.js","assets/hack-BTX3ICIE.js","assets/handlebars-yWFGGD2R.js","assets/http-DjsOm9E4.js","assets/hurl-Am2cDU4f.js","assets/csv-Ba84L8e5.js","assets/hxml-Jle7oGdm.js","assets/haxe-BpobLYM9.js","assets/jinja-FkIlHBgj.js","assets/jison-BkdOIOd4.js","assets/julia-CU_UwNb8.js","assets/r-Dpdc-Kyk.js","assets/latex-BRmxFpXE.js","assets/tex-CcHKQ11y.js","assets/liquid-QmJ_LYTW.js","assets/marko-BDLRyCCe.js","assets/less-BAzLMJNR.js","assets/mdc-BQMA9IL9.js","assets/nginx-BFAkI5_-.js","assets/nim-B3PAIZ4D.js","assets/perl-HITCDkgu.js","assets/php-C2HieitX.js","assets/pug-BwQB43qN.js","assets/qml-jtL8okyu.js","assets/razor-gBXW6YBJ.js","assets/csharp-DxX_6tHh.js","assets/rst-CKCyRjfY.js","assets/cmake-CDfQILeU.js","assets/sas-BLBgC3TA.js","assets/shaderlab-C07uO3dL.js","assets/hlsl-TRzjajlb.js","assets/shellsession-CkeTp4M1.js","assets/soy-BHaHgMUy.js","assets/sparql-DswowMAp.js","assets/turtle-BnC7StHY.js","assets/stata-Dl7wDdBE.js","assets/surrealql-Bs3vUeKA.js","assets/svelte-BAOk4slW.js","assets/templ-CSEiQwNm.js","assets/go-DRMr3iML.js","assets/ts-tags-cG2hZuda.js","assets/twig-CDYLbMhD.js","assets/vue-K-7Ga-y8.js","assets/vue-html-DhreShjd.js","assets/vue-vine-rMIwOpFf.js","assets/stylus-DXFa_2Jl.js","assets/xsl-CnwVr_6q.js"])))=>i.map(i=>d[i]);
import { A as reactive, d as defineComponent, Z as toRefs, _ as useRouter, k as watch, n as ref, m as useRoute, c as computed, o as openBlock, a as createElementBlock, g as createCommentVNode, e as unref, y as createBlock, p as withCtx, f as createVNode, I as Icon, z as createTextVNode, V as watchEffect, $ as nextTick, h as defineStore, a0 as useResizeObserver, s as resolveComponent, a1 as renderSlot, b as createBaseVNode, M as h, a2 as onBeforeUnmount, X as mergeProps, T as Transition, q as normalizeClass, t as toDisplayString, a3 as d0, a4 as e0, a5 as n0, a6 as s0, r as resolveDirective, w as withDirectives, a7 as withModifiers, Y as resolveDynamicComponent, F as Fragment, x as renderList, a8 as kt, a9 as clone, aa as omit, j as useStorage, G as onMounted, ab as useTimeoutFn, ac as onClickOutside, ad as vModelText, v as withKeys, i as isRef, N as applyState, ae as toHtml, af as FontStyle, ag as INITIAL, ah as EncodedTokenMetadata, ai as Registry$1, aj as Theme, W as markRaw, ak as shallowRef, al as f0, am as unindent, l as useCssVars, B as normalizeStyle, an as onUnmounted, ao as createStaticVNode, ap as Ot, u as useEventListener, aq as toRaw } from "./vendor-D7amjHY-.js";
import { u as useStoryStore } from "./story-Cz4GQpQy.js";
import { _ as _export_sfc, b as BaseSplitPane, u as useScrollOnActive, i as isMobile, B as BaseListItemLink, a as _sfc_main$A } from "./responsive-Bp3G1Fj7.js";
import { B as BaseEmpty } from "./BaseEmpty.vue-BEf0a62x.js";
import { h as histoireConfig, _ as __vitePreload, d as clientSupportPlugins, i as isDark, e as base } from "./mapping-BiDbjwnH.js";
import { t as toRawDeep, _ as _sfc_main$z, g as getContrastColor, S as SANDBOX_READY, E as EVENT_SEND, a as STATE_SYNC, P as PREVIEW_SETTINGS_SYNC } from "./state-BlQZFlXN.js";
const markdownFiles = reactive({});
const _hoisted_1$t = ["innerHTML"];
function useStoryDoc(story) {
  const renderedDoc = ref("");
  watchEffect(async () => {
    const mdKey = story.value.file.filePath.replace(/\.(\w*)$/, ".md");
    if (markdownFiles[mdKey]) {
      const md = await markdownFiles[mdKey]();
      renderedDoc.value = md.html;
      return;
    }
    let comp = story.value.file?.component;
    if (comp) {
      if (comp.__asyncResolved) {
        comp = comp.__asyncResolved;
      } else if (comp.__asyncLoader) {
        comp = await comp.__asyncLoader();
      } else if (typeof comp === "function") {
        try {
          comp = await comp();
        } catch (e) {
        }
      }
      if (comp?.default) {
        comp = comp.default;
      }
      renderedDoc.value = comp.doc;
    }
  });
  return {
    renderedDoc
  };
}
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "StoryDocs",
  props: {
    story: {
      type: Object,
      required: true
    },
    standalone: {
      type: Boolean,
      default: false
    }
  },
  emits: ["scrollTop"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { story } = toRefs(props);
    const { renderedDoc } = useStoryDoc(story);
    const router = useRouter();
    const fakeHost = `http://a.com`;
    function onClick(e) {
      const link = e.target.closest("a");
      if (link && link.getAttribute("data-route") && !e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey && link.target !== `_blank`) {
        e.preventDefault();
        const url = new URL(link.href, fakeHost);
        const targetHref = url.pathname + url.search + url.hash;
        router.push(targetHref);
      }
    }
    function getHash() {
      const hash = location.hash;
      if (histoireConfig.routerMode === "hash") {
        const index = hash.indexOf("#", 1);
        if (index !== -1) {
          return hash.slice(index);
        } else {
          return void 0;
        }
      }
      return hash;
    }
    async function scrollToAnchor() {
      await nextTick();
      const hash = getHash();
      if (hash) {
        const anchor = document.querySelector(decodeURIComponent(hash));
        if (anchor) {
          anchor.scrollIntoView();
          return;
        }
      }
      emit("scrollTop");
    }
    watch(renderedDoc, () => {
      scrollToAnchor();
    }, {
      immediate: true
    });
    const renderedEl = ref();
    const route = useRoute();
    async function patchAnchorLinks() {
      await nextTick();
      if (histoireConfig.routerMode === "hash" && renderedEl.value) {
        const links = renderedEl.value.querySelectorAll("a.header-anchor");
        for (const link of links) {
          const href = link.getAttribute("href");
          if (href) {
            link.setAttribute("href", `#${route.path + href}`);
          }
        }
      }
    }
    watch(renderedDoc, () => {
      patchAnchorLinks();
    }, {
      immediate: true
    });
    computed(() => story.value.file?.docsFilePath ?? (props.standalone && story.value.file?.filePath));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "histoire-story-docs",
        onClickCapture: onClick
      }, [
        createCommentVNode("", true),
        !unref(renderedDoc) ? (openBlock(), createBlock(BaseEmpty, { key: 1 }, {
          default: withCtx(() => [
            createVNode(unref(Icon), {
              icon: "carbon:document-unknown",
              class: "htw-w-8 htw-h-8 htw-opacity-50 htw-mb-6"
            }),
            _cache[0] || (_cache[0] = createTextVNode(" No documentation available ", -1))
          ]),
          _: 1
        })) : (openBlock(), createElementBlock("div", {
          key: 2,
          ref_key: "renderedEl",
          ref: renderedEl,
          class: "htw-prose dark:htw-prose-invert htw-p-4 htw-max-w-none",
          "data-test-id": "story-docs",
          innerHTML: unref(renderedDoc)
        }, null, 8, _hoisted_1$t))
      ], 32);
    };
  }
});
const useEventsStore = defineStore("events", () => {
  const storyStore = useStoryStore();
  const events = reactive([]);
  const unseen = ref(0);
  function addEvent(event) {
    events.push(event);
    unseen.value++;
  }
  function reset() {
    events.length = 0;
    unseen.value = 0;
  }
  watch(() => storyStore.currentVariant?.id, () => {
    reset();
  });
  return {
    addEvent,
    reset,
    events,
    unseen
  };
});
const _hoisted_1$s = {
  role: "button",
  class: "htw-cursor-pointer hover:htw-bg-primary-50 dark:hover:htw-bg-primary-900 htw-w-8 htw-h-full htw-flex htw-items-center htw-justify-center htw-absolute htw-top-0 htw-right-0"
};
const _hoisted_2$h = { class: "htw-flex htw-flex-col htw-items-stretch" };
const overflowButtonWidth = 32;
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "BaseOverflowMenu",
  setup(__props) {
    const el = ref();
    const availableWidth = ref(0);
    useResizeObserver(el, (entries) => {
      const containerWidth = entries[0].contentRect.width;
      availableWidth.value = containerWidth - overflowButtonWidth;
    });
    const children = ref(/* @__PURE__ */ new Map());
    const visibleChildrenCount = computed(() => {
      let width = 0;
      const c = [...children.value.values()].sort((a, b) => a.index - b.index);
      for (let i = 0; i < c.length; i++) {
        width += c[i].width;
        if (width > availableWidth.value) {
          return i;
        }
      }
      return c.length;
    });
    const ChildWrapper = {
      name: "ChildWrapper",
      props: ["index"],
      setup(props, { slots }) {
        const el2 = ref();
        const state = reactive({ width: 0, index: props.index });
        useResizeObserver(el2, (entries) => {
          const width = entries[0].contentRect.width;
          if (!children.value.has(el2.value)) {
            children.value.set(el2.value, state);
          }
          state.width = width;
        });
        onBeforeUnmount(() => {
          children.value.delete(el2.value);
        });
        const visible = computed(() => visibleChildrenCount.value > state.index);
        return () => h("div", { ref: el2, style: { visibility: visible.value ? "visible" : "hidden" } }, slots.default());
      }
    };
    function ChildrenRender(props, { slots }) {
      const [fragment] = slots.default();
      return fragment.children.map((vnode, index) => h(ChildWrapper, { index }, () => [vnode]));
    }
    function ChildrenSlice(props, { slots }) {
      const [fragment] = slots.default();
      return fragment.children.slice(props.start, props.end);
    }
    return (_ctx, _cache) => {
      const _component_VDropdown = resolveComponent("VDropdown");
      return openBlock(), createElementBlock("div", {
        ref_key: "el",
        ref: el,
        class: "histoire-base-overflow-menu htw-flex htw-overflow-hidden htw-relative"
      }, [
        createVNode(ChildrenRender, null, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }),
        visibleChildrenCount.value < children.value.size ? (openBlock(), createBlock(_component_VDropdown, { key: 0 }, {
          popper: withCtx(() => [
            createBaseVNode("div", _hoisted_2$h, [
              createVNode(ChildrenSlice, { start: visibleChildrenCount.value }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "overflow")
                ]),
                _: 3
              }, 8, ["start"])
            ])
          ]),
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_1$s, [
              createVNode(unref(Icon), {
                icon: "carbon:caret-down",
                class: "htw-w-4 htw-h-4 htw-opacity-50 group-hover:htw-opacity-100"
              })
            ])
          ]),
          _: 3
        })) : createCommentVNode("", true)
      ], 512);
    };
  }
});
const _sfc_main$w = defineComponent({
  inheritAttrs: false,
  props: {
    exact: {
      type: Boolean,
      default: false
    },
    matched: {
      type: Boolean,
      default: null
    }
  }
});
const _hoisted_1$r = ["href", "onClick"];
const _hoisted_2$g = {
  key: 0,
  class: "htw-absolute htw-top-0 htw-left-0 htw-h-full htw-w-[2px] htw-bg-primary-500 dark:htw-bg-primary-400"
};
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_router_link = resolveComponent("router-link");
  return openBlock(), createBlock(_component_router_link, mergeProps({ class: "histoire-base-overflow-tab" }, _ctx.$attrs, { custom: "" }), {
    default: withCtx(({ isActive, isExactActive, href, navigate }) => [
      createBaseVNode("a", mergeProps(_ctx.$attrs, {
        href,
        class: ["htw-px-4 htw-h-10 htw-min-w-[150px] htw-inline-flex htw-items-center hover:htw-bg-primary-50 dark:hover:htw-bg-primary-900 htw-relative htw-text-gray-900 dark:htw-text-gray-100", {
          "htw-text-primary-500 dark:htw-text-primary-400": _ctx.matched != null ? _ctx.matched : _ctx.exact && isExactActive || !_ctx.exact && isActive
        }],
        onClick: navigate
      }), [
        renderSlot(_ctx.$slots, "default"),
        createVNode(Transition, { name: "__histoire-scale-y" }, {
          default: withCtx(() => [
            (_ctx.matched != null ? _ctx.matched : _ctx.exact && isExactActive || !_ctx.exact && isActive) ? (openBlock(), createElementBlock("div", _hoisted_2$g)) : createCommentVNode("", true)
          ]),
          _: 2
        }, 1024)
      ], 16, _hoisted_1$r)
    ]),
    _: 3
  }, 16);
}
const BaseOverflowTab = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$4]]);
const _sfc_main$v = defineComponent({
  inheritAttrs: false,
  props: {
    exact: {
      type: Boolean,
      default: false
    },
    matched: {
      type: Boolean,
      default: null
    }
  }
});
const _hoisted_1$q = ["href", "onClick"];
const _hoisted_2$f = {
  key: 0,
  class: "htw-absolute htw-bottom-0 htw-left-0 htw-w-full htw-h-[2px] htw-bg-primary-500 dark:htw-bg-primary-400"
};
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_router_link = resolveComponent("router-link");
  return openBlock(), createBlock(_component_router_link, mergeProps({ class: "histoire-base-tab" }, _ctx.$attrs, { custom: "" }), {
    default: withCtx(({ isActive, isExactActive, href, navigate }) => [
      createBaseVNode("a", mergeProps(_ctx.$attrs, {
        href,
        class: ["htw-px-4 htw-h-full htw-inline-flex htw-items-center hover:htw-bg-primary-50 dark:hover:htw-bg-primary-900 htw-relative htw-text-gray-900 dark:htw-text-gray-100", {
          "htw-text-primary-500 dark:htw-text-primary-400": _ctx.matched != null ? _ctx.matched : _ctx.exact && isExactActive || !_ctx.exact && isActive
        }],
        onClick: navigate
      }), [
        renderSlot(_ctx.$slots, "default"),
        createVNode(Transition, { name: "__histoire-scale-x" }, {
          default: withCtx(() => [
            (_ctx.matched != null ? _ctx.matched : _ctx.exact && isExactActive || !_ctx.exact && isActive) ? (openBlock(), createElementBlock("div", _hoisted_2$f)) : createCommentVNode("", true)
          ]),
          _: 2
        }, 1024)
      ], 16, _hoisted_1$q)
    ]),
    _: 3
  }, 16);
}
const BaseTab = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$3]]);
const _sfc_main$u = {};
const _hoisted_1$p = { class: "histoire-base-tag htw-text-center htw-text-xs htw-mx-1 htw-px-0.5 htw-h-4 htw-uppercase htw-min-w-4 htw-rounded-full htw-bg-primary-500 htw-text-white dark:htw-text-black" };
function _sfc_render$2(_ctx, _cache) {
  return openBlock(), createElementBlock("span", _hoisted_1$p, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
const BaseTag = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$2]]);
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "PaneTabs",
  props: {
    story: {},
    variant: {}
  },
  setup(__props) {
    const props = __props;
    const { story } = toRefs(props);
    const { renderedDoc } = useStoryDoc(story);
    const eventsStore = useEventsStore();
    const hasEvents = computed(() => eventsStore.events.length);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$x, { class: "histoire-pane-tabs htw-h-10 htw-flex-none htw-border-b htw-border-gray-100 dark:htw-border-gray-750" }, {
        overflow: withCtx(() => [
          createVNode(BaseOverflowTab, {
            to: { ..._ctx.$route, query: { ..._ctx.$route.query, tab: "" } },
            matched: !_ctx.$route.query.tab
          }, {
            default: withCtx(() => [..._cache[3] || (_cache[3] = [
              createTextVNode(" Controls ", -1)
            ])]),
            _: 1
          }, 8, ["to", "matched"]),
          createVNode(BaseOverflowTab, {
            to: { ..._ctx.$route, query: { ..._ctx.$route.query, tab: "docs" } },
            matched: _ctx.$route.query.tab === "docs",
            class: normalizeClass({
              "opacity-50": !unref(renderedDoc)
            })
          }, {
            default: withCtx(() => [..._cache[4] || (_cache[4] = [
              createTextVNode(" Docs ", -1)
            ])]),
            _: 1
          }, 8, ["to", "matched", "class"]),
          createVNode(BaseOverflowTab, {
            to: { ..._ctx.$route, query: { ..._ctx.$route.query, tab: "events" } },
            matched: _ctx.$route.query.tab === "events",
            class: normalizeClass({
              "htw-opacity-50": !hasEvents.value
            })
          }, {
            default: withCtx(() => [
              _cache[5] || (_cache[5] = createTextVNode(" Events ", -1)),
              unref(eventsStore).unseen ? (openBlock(), createBlock(BaseTag, { key: 0 }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(unref(eventsStore).unseen <= 99 ? unref(eventsStore).unseen : "99+"), 1)
                ]),
                _: 1
              })) : createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["to", "matched", "class"])
        ]),
        default: withCtx(() => [
          createVNode(BaseTab, {
            to: { ..._ctx.$route, query: { ..._ctx.$route.query, tab: "" } },
            matched: !_ctx.$route.query.tab
          }, {
            default: withCtx(() => [..._cache[0] || (_cache[0] = [
              createTextVNode(" Controls ", -1)
            ])]),
            _: 1
          }, 8, ["to", "matched"]),
          createVNode(BaseTab, {
            to: { ..._ctx.$route, query: { ..._ctx.$route.query, tab: "docs" } },
            matched: _ctx.$route.query.tab === "docs",
            class: normalizeClass({
              "htw-opacity-50": !unref(renderedDoc)
            })
          }, {
            default: withCtx(() => [..._cache[1] || (_cache[1] = [
              createTextVNode(" Docs ", -1)
            ])]),
            _: 1
          }, 8, ["to", "matched", "class"]),
          createVNode(BaseTab, {
            to: { ..._ctx.$route, query: { ..._ctx.$route.query, tab: "events" } },
            matched: _ctx.$route.query.tab === "events",
            class: normalizeClass({
              "htw-opacity-50": !hasEvents.value
            })
          }, {
            default: withCtx(() => [
              _cache[2] || (_cache[2] = createTextVNode(" Events ", -1)),
              unref(eventsStore).unseen ? (openBlock(), createBlock(BaseTag, { key: 0 }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(unref(eventsStore).unseen <= 99 ? unref(eventsStore).unseen : "99+"), 1)
                ]),
                _: 1
              })) : createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["to", "matched", "class"])
        ]),
        _: 1
      });
    };
  }
});
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "ControlsComponentPropItem",
  props: {
    variant: {},
    component: {},
    definition: {}
  },
  setup(__props) {
    const props = __props;
    const comp = computed(() => {
      switch (props.definition.types?.[0]) {
        case "string":
          return s0;
        case "number":
          return n0;
        case "boolean":
          return e0;
        case "object":
        default:
          return d0;
      }
    });
    const model = computed({
      get: () => {
        return props.variant.state._hPropState[props.component.index]?.[props.definition.name];
      },
      set: (value) => {
        if (!props.variant.state._hPropState[props.component.index]) {
          props.variant.state._hPropState[props.component.index] = {};
        }
        props.variant.state._hPropState[props.component.index][props.definition.name] = value;
      }
    });
    function reset() {
      if (props.variant.state._hPropState[props.component.index]) {
        delete props.variant.state._hPropState[props.component.index][props.definition.name];
      }
    }
    const canReset = computed(() => props.variant.state?._hPropState?.[props.component.index] && props.definition.name in props.variant.state._hPropState[props.component.index]);
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return comp.value ? (openBlock(), createBlock(resolveDynamicComponent(comp.value), {
        key: 0,
        modelValue: model.value,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => model.value = $event),
        placeholder: model.value === void 0 ? __props.definition?.default : null,
        class: "histoire-controls-component-prop-item",
        title: `${__props.definition.name}${canReset.value ? " *" : ""}`
      }, {
        actions: withCtx(() => [
          withDirectives(createVNode(unref(Icon), {
            icon: "carbon:erase",
            class: normalizeClass(["htw-cursor-pointer htw-w-4 htw-h-4 hover:htw-text-primary-500 dark:hover:htw-text-primary-400 htw-text-gray-900 dark:htw-text-gray-100", [
              canReset.value ? "htw-opacity-50 hover:htw-opacity-100" : "htw-opacity-25 htw-pointer-events-none"
            ]]),
            onClick: _cache[0] || (_cache[0] = withModifiers(($event) => reset(), ["stop"]))
          }, null, 8, ["class"]), [
            [_directive_tooltip, "Remove override"]
          ])
        ]),
        _: 1
      }, 8, ["modelValue", "placeholder", "title"])) : createCommentVNode("", true);
    };
  }
});
const _hoisted_1$o = { class: "histoire-controls-component-props" };
const _hoisted_2$e = { class: "htw-font-mono htw-p-2 htw-flex htw-items-center htw-gap-1" };
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "ControlsComponentProps",
  props: {
    variant: {},
    definition: {}
  },
  setup(__props) {
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock("div", _hoisted_1$o, [
        createBaseVNode("div", _hoisted_2$e, [
          withDirectives(createVNode(unref(Icon), {
            icon: "carbon:flash",
            class: "htw-w-4 htw-h-4 htw-text-primary-500 htw-flex-none"
          }, null, 512), [
            [_directive_tooltip, "Auto-detected props"]
          ]),
          createBaseVNode("div", null, [
            _cache[0] || (_cache[0] = createBaseVNode("span", { class: "htw-opacity-30" }, "<", -1)),
            createTextVNode(toDisplayString(__props.definition.name), 1),
            _cache[1] || (_cache[1] = createBaseVNode("span", { class: "htw-opacity-30" }, ">", -1))
          ])
        ]),
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.definition.props, (prop) => {
          return openBlock(), createBlock(_sfc_main$s, {
            key: prop.name,
            variant: __props.variant,
            component: __props.definition,
            definition: prop
          }, null, 8, ["variant", "component", "definition"]);
        }), 128))
      ]);
    };
  }
});
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "ControlsComponentStateItem",
  props: {
    variant: {},
    item: {}
  },
  setup(__props) {
    const props = __props;
    const comp = computed(() => {
      switch (typeof props.variant.state[props.item]) {
        case "string":
          return s0;
        case "number":
          return n0;
        case "boolean":
          return e0;
        case "object":
        default:
          return d0;
      }
    });
    const model = computed({
      get: () => {
        return props.variant.state[props.item];
      },
      set: (value) => {
        props.variant.state[props.item] = value;
      }
    });
    return (_ctx, _cache) => {
      return comp.value ? (openBlock(), createBlock(resolveDynamicComponent(comp.value), {
        key: 0,
        modelValue: model.value,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => model.value = $event),
        class: "histoire-controls-component-prop-item",
        title: props.item
      }, null, 8, ["modelValue", "title"])) : createCommentVNode("", true);
    };
  }
});
const _hoisted_1$n = { class: "histoire-controls-component-init-state" };
const _hoisted_2$d = { class: "htw-p-2 htw-flex htw-items-center htw-gap-1" };
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "ControlsComponentState",
  props: {
    variant: {}
  },
  setup(__props) {
    const props = __props;
    const stateKeys = computed(() => Object.keys(props.variant.state || {}).filter((key) => !key.startsWith("_h")));
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock("div", _hoisted_1$n, [
        createBaseVNode("div", _hoisted_2$d, [
          withDirectives(createVNode(unref(Icon), {
            icon: "carbon:data-vis-1",
            class: "htw-w-4 htw-h-4 htw-text-primary-500 htw-flex-none"
          }, null, 512), [
            [_directive_tooltip, "Auto-detected state"]
          ]),
          _cache[0] || (_cache[0] = createBaseVNode("div", null, " State ", -1))
        ]),
        (openBlock(true), createElementBlock(Fragment, null, renderList(stateKeys.value, (key) => {
          return openBlock(), createBlock(_sfc_main$q, {
            key,
            item: key,
            variant: __props.variant
          }, null, 8, ["item", "variant"]);
        }), 128))
      ]);
    };
  }
});
const _hoisted_1$m = { class: "htw-cursor-pointer htw-w-full htw-outline-none htw-px-2 htw-h-[27px] -htw-my-1 htw-border htw-border-solid htw-border-black/25 dark:htw-border-white/25 hover:htw-border-primary-500 dark:hover:htw-border-primary-500 htw-rounded-sm htw-flex htw-gap-2 htw-items-center htw-leading-normal" };
const _hoisted_2$c = { class: "htw-flex-1 htw-truncate" };
const _hoisted_3$b = { class: "htw-flex htw-flex-col htw-bg-gray-50 dark:htw-bg-gray-700" };
const _hoisted_4$7 = ["onClick"];
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "BaseSelect",
  props: {
    modelValue: {},
    options: {}
  },
  emits: ["update:modelValue", "select"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const formattedOptions = computed(() => {
      if (Array.isArray(props.options)) {
        return Object.fromEntries(props.options.map((value) => [value, value]));
      }
      return props.options;
    });
    const selectedLabel = computed(() => formattedOptions.value[props.modelValue]);
    function selectValue(value, hide) {
      emit("update:modelValue", value);
      emit("select", value);
      hide();
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(kt), {
        class: "histoire-base-select",
        "auto-size": "",
        "auto-boundary-max-size": ""
      }, {
        popper: withCtx(({ hide }) => [
          createBaseVNode("div", _hoisted_3$b, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(formattedOptions.value, (label, value) => {
              return openBlock(), createElementBlock("div", mergeProps({ ref_for: true }, { ..._ctx.$attrs, class: null, style: null }, {
                key: label,
                class: ["htw-px-2 htw-py-1 htw-cursor-pointer hover:htw-bg-primary-100 dark:hover:htw-bg-primary-700", {
                  "htw-bg-primary-200 dark:htw-bg-primary-800": props.modelValue === value
                }],
                onClick: ($event) => selectValue(value, hide)
              }), [
                renderSlot(_ctx.$slots, "option", {
                  label,
                  value
                }, () => [
                  createTextVNode(toDisplayString(label), 1)
                ])
              ], 16, _hoisted_4$7);
            }), 128))
          ])
        ]),
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$m, [
            createBaseVNode("div", _hoisted_2$c, [
              renderSlot(_ctx.$slots, "default", { label: selectedLabel.value }, () => [
                createTextVNode(toDisplayString(selectedLabel.value), 1)
              ])
            ]),
            createVNode(unref(Icon), {
              icon: "carbon:chevron-sort",
              class: "htw-w-4 htw-h-4 htw-flex-none htw-ml-auto"
            })
          ])
        ]),
        _: 3
      });
    };
  }
});
const _hoisted_1$l = { class: "histoire-state-presets htw-flex htw-gap-2 htw-w-full htw-items-center" };
const _hoisted_2$b = ["onUpdate:modelValue"];
const _hoisted_3$a = {
  key: 1,
  class: "htw-flex htw-items-center htw-gap-2"
};
const _hoisted_4$6 = { class: "htw-flex-1 htw-truncate" };
const _hoisted_5$5 = { class: "htw-flex htw-gap-2 htw-items-center" };
const _hoisted_6$3 = { class: "htw-flex-1 htw-truncate" };
const DEFAULT_ID = "default";
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "StatePresets",
  props: {
    story: {},
    variant: {}
  },
  setup(__props) {
    const props = __props;
    const saveId = computed(() => `${props.story.id}:${props.variant.id}`);
    const omitKeys = ["_hPropDefs"];
    const defaultState = clone(omit(toRawDeep(props.variant.state), omitKeys));
    const selectedOption = useStorage(
      `_histoire-presets/${saveId.value}/selected`,
      DEFAULT_ID
    );
    const presetStates = useStorage(
      `_histoire-presets/${saveId.value}/states`,
      /* @__PURE__ */ new Map()
    );
    const presetsOptions = computed(() => {
      const options = { [DEFAULT_ID]: "Initial state" };
      presetStates.value.forEach((value, key) => {
        options[key] = value.label;
      });
      return options;
    });
    function resetState() {
      selectedOption.value = DEFAULT_ID;
      applyState(props.variant.state, clone(defaultState));
    }
    function applyPreset(id) {
      if (id === DEFAULT_ID) {
        resetState();
      } else if (presetStates.value.has(id)) {
        applyState(props.variant.state, clone(toRawDeep(presetStates.value.get(id).state)));
      }
    }
    onMounted(() => {
      if (selectedOption.value !== DEFAULT_ID) {
        applyPreset(selectedOption.value);
      }
    });
    const input = ref();
    const select = ref();
    const canEdit = computed(() => selectedOption.value !== DEFAULT_ID);
    const isEditing = ref(false);
    async function createPreset() {
      const id = (/* @__PURE__ */ new Date()).getTime().toString();
      presetStates.value.set(id, { state: clone(omit(toRawDeep(props.variant.state), omitKeys)), label: "New preset" });
      selectedOption.value = id;
      isEditing.value = true;
      await nextTick();
      input.value.select();
    }
    const savedNotif = ref(false);
    const savedTimeout = useTimeoutFn(() => {
      savedNotif.value = false;
    }, 1e3);
    async function savePreset() {
      if (!canEdit.value) return;
      const preset = presetStates.value.get(selectedOption.value);
      preset.state = clone(omit(toRawDeep(props.variant.state), omitKeys));
      savedNotif.value = true;
      savedTimeout.start();
    }
    function deletePreset(id) {
      if (!confirm("Are you sure you want to delete this preset?")) {
        return;
      }
      if (selectedOption.value === id) {
        resetState();
      }
      presetStates.value.delete(id);
    }
    async function startEditing() {
      if (!canEdit.value) {
        return;
      }
      isEditing.value = true;
      await nextTick();
      input.value.select();
    }
    function stopEditing() {
      isEditing.value = false;
    }
    onClickOutside(select, stopEditing);
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock("div", _hoisted_1$l, [
        createBaseVNode("div", {
          ref_key: "select",
          ref: select,
          class: "htw-flex-1 htw-min-w-0"
        }, [
          createVNode(_sfc_main$o, {
            modelValue: unref(selectedOption),
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => isRef(selectedOption) ? selectedOption.value = $event : null),
            options: presetsOptions.value,
            onDblclick: _cache[3] || (_cache[3] = ($event) => startEditing()),
            onKeydown: [
              _cache[4] || (_cache[4] = withKeys(($event) => stopEditing(), ["enter"])),
              _cache[5] || (_cache[5] = withKeys(($event) => stopEditing(), ["escape"]))
            ],
            onSelect: _cache[6] || (_cache[6] = (id) => applyPreset(id))
          }, {
            default: withCtx(({ label }) => [
              isEditing.value ? withDirectives((openBlock(), createElementBlock("input", {
                key: 0,
                ref_key: "input",
                ref: input,
                "onUpdate:modelValue": ($event) => unref(presetStates).get(unref(selectedOption)).label = $event,
                type: "text",
                class: "htw-text-inherit htw-bg-transparent htw-w-full htw-h-full htw-outline-none",
                onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                }, ["stop", "prevent"]))
              }, null, 8, _hoisted_2$b)), [
                [vModelText, unref(presetStates).get(unref(selectedOption)).label]
              ]) : (openBlock(), createElementBlock("div", _hoisted_3$a, [
                createBaseVNode("span", _hoisted_4$6, toDisplayString(label), 1),
                canEdit.value ? withDirectives((openBlock(), createBlock(unref(Icon), {
                  key: 0,
                  icon: "carbon:edit",
                  class: "htw-flex-none htw-cursor-pointer htw-w-4 htw-h-4 hover:htw-text-primary-500 htw-opacity-50 hover:htw-opacity-100 dark:hover:htw-text-primary-400 htw-text-gray-900 dark:htw-text-gray-100",
                  onClick: _cache[1] || (_cache[1] = withModifiers(($event) => startEditing(), ["stop"]))
                }, null, 512)), [
                  [_directive_tooltip, "Rename this preset"]
                ]) : createCommentVNode("", true)
              ]))
            ]),
            option: withCtx(({ label, value }) => [
              createBaseVNode("div", _hoisted_5$5, [
                createBaseVNode("span", _hoisted_6$3, toDisplayString(label), 1),
                value !== DEFAULT_ID ? withDirectives((openBlock(), createBlock(unref(Icon), {
                  key: 0,
                  icon: "carbon:trash-can",
                  class: "htw-flex-none htw-cursor-pointer htw-w-4 htw-h-4 hover:htw-text-primary-500 htw-opacity-50 hover:htw-opacity-100 dark:hover:htw-text-primary-400 htw-text-gray-900 dark:htw-text-gray-100",
                  onClick: withModifiers(($event) => deletePreset(value), ["stop"])
                }, null, 8, ["onClick"])), [
                  [_directive_tooltip, "Delete this preset"]
                ]) : createCommentVNode("", true)
              ])
            ]),
            _: 1
          }, 8, ["modelValue", "options"])
        ], 512),
        withDirectives(createVNode(unref(Icon), {
          icon: savedNotif.value ? "carbon:checkmark" : "carbon:save",
          class: normalizeClass(["htw-cursor-pointer htw-w-4 htw-h-4 hover:htw-text-primary-500 dark:hover:htw-text-primary-400 htw-text-gray-900 dark:htw-text-gray-100", [
            canEdit.value ? "htw-opacity-50 hover:htw-opacity-100" : "htw-opacity-25 htw-pointer-events-none"
          ]]),
          onClick: _cache[7] || (_cache[7] = ($event) => savePreset())
        }, null, 8, ["icon", "class"]), [
          [_directive_tooltip, savedNotif.value ? "Saved!" : canEdit.value ? "Save to preset" : null]
        ]),
        withDirectives(createVNode(unref(Icon), {
          icon: "carbon:add-alt",
          class: "htw-cursor-pointer htw-w-4 htw-h-4 hover:htw-text-primary-500 htw-opacity-50 hover:htw-opacity-100 dark:hover:htw-text-primary-400 htw-text-gray-900 dark:htw-text-gray-100",
          onClick: _cache[8] || (_cache[8] = ($event) => createPreset())
        }, null, 512), [
          [_directive_tooltip, "Create new preset"]
        ]),
        withDirectives(createVNode(unref(Icon), {
          icon: "carbon:reset",
          class: "htw-cursor-pointer htw-w-4 htw-h-4 hover:htw-text-primary-500 htw-opacity-50 hover:htw-opacity-100 dark:hover:htw-text-primary-400 htw-text-gray-900 dark:htw-text-gray-100",
          onClick: _cache[9] || (_cache[9] = ($event) => resetState())
        }, null, 512), [
          [_directive_tooltip, "Reset to initial state"]
        ])
      ]);
    };
  }
});
const _hoisted_1$k = {
  "data-test-id": "story-controls",
  class: "histoire-story-controls htw-flex htw-flex-col htw-divide-y htw-divide-gray-100 dark:htw-divide-gray-750"
};
const _hoisted_2$a = { class: "htw-h-9 htw-flex-none htw-px-2 htw-flex htw-items-center" };
const _hoisted_3$9 = { key: 1 };
const _hoisted_4$5 = { key: 3 };
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "StoryControls",
  props: {
    variant: {
      type: Object,
      required: true
    },
    story: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const ready = ref(false);
    watch(() => props.variant, () => {
      ready.value = false;
    });
    const hasCustomControls = computed(() => props.variant.slots().controls || props.story.slots().controls);
    const hasInitState = computed(() => Object.entries(props.variant.state || {}).filter(([key]) => !key.startsWith("_h")).length > 0);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$k, [
        createBaseVNode("div", _hoisted_2$a, [
          ready.value || !hasCustomControls.value ? (openBlock(), createBlock(_sfc_main$n, {
            key: 0,
            story: __props.story,
            variant: __props.variant
          }, null, 8, ["story", "variant"])) : createCommentVNode("", true)
        ]),
        hasCustomControls.value ? (openBlock(), createBlock(_sfc_main$z, {
          key: `${__props.story.id}-${__props.variant.id}`,
          "slot-name": "controls",
          variant: __props.variant,
          story: __props.story,
          class: "__histoire-render-custom-controls htw-flex-none",
          onReady: _cache[0] || (_cache[0] = ($event) => ready.value = true)
        }, null, 8, ["variant", "story"])) : hasInitState.value ? (openBlock(), createElementBlock("div", _hoisted_3$9, [
          createVNode(_sfc_main$p, {
            class: "htw-flex-none htw-my-2",
            variant: __props.variant
          }, null, 8, ["variant"])
        ])) : !__props.variant.state?._hPropDefs?.length ? (openBlock(), createBlock(BaseEmpty, { key: 2 }, {
          default: withCtx(() => [
            createVNode(unref(Icon), {
              icon: "carbon:audio-console",
              class: "htw-w-8 htw-h-8 htw-opacity-50 htw-mb-6"
            }),
            _cache[1] || (_cache[1] = createBaseVNode("span", null, "No controls available for this story", -1))
          ]),
          _: 1
        })) : createCommentVNode("", true),
        __props.variant.state?._hPropDefs?.length ? (openBlock(), createElementBlock("div", _hoisted_4$5, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.variant.state._hPropDefs, (def, index) => {
            return openBlock(), createBlock(_sfc_main$r, {
              key: index,
              variant: __props.variant,
              definition: def,
              class: "htw-flex-none htw-my-2"
            }, null, 8, ["variant", "definition"]);
          }), 128))
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
const _hoisted_1$j = {
  key: 0,
  class: "htw-text-xs htw-opacity-50 htw-truncate"
};
const _hoisted_2$9 = { class: "htw-overflow-auto htw-max-w-[400px] htw-max-h-[400px]" };
const _hoisted_3$8 = { class: "htw-p-4" };
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "StoryEvent",
  props: {
    event: {}
  },
  setup(__props) {
    const props = __props;
    const formattedArgument = computed(() => {
      switch (typeof props.event.argument) {
        case "string":
          return `"${props.event.argument}"`;
        case "object":
          return `{ ${Object.keys(props.event.argument).map((key) => `${key}: ${props.event.argument[key]}`).join(", ")} }`;
        default:
          return props.event.argument;
      }
    });
    return (_ctx, _cache) => {
      const _component_VDropdown = resolveComponent("VDropdown");
      return openBlock(), createBlock(_component_VDropdown, {
        class: "histoire-story-event htw-group",
        placement: "right",
        "data-test-id": "event-item"
      }, {
        default: withCtx(({ shown }) => [
          createBaseVNode("div", {
            class: normalizeClass(["group-hover:htw-bg-primary-100 dark:group-hover:htw-bg-primary-700 htw-cursor-pointer htw-py-2 htw-px-4 htw-flex htw-items-baseline htw-gap-1 htw-leading-normal", [
              shown ? "htw-bg-primary-50 dark:htw-bg-primary-600" : "group-odd:htw-bg-gray-100/50 dark:group-odd:htw-bg-gray-750/40"
            ]])
          }, [
            createBaseVNode("span", {
              class: normalizeClass({
                "htw-text-primary-500": shown
              })
            }, toDisplayString(__props.event.name), 3),
            __props.event.argument ? (openBlock(), createElementBlock("span", _hoisted_1$j, toDisplayString(formattedArgument.value), 1)) : createCommentVNode("", true)
          ], 2)
        ]),
        popper: withCtx(() => [
          createBaseVNode("div", _hoisted_2$9, [
            createBaseVNode("pre", _hoisted_3$8, toDisplayString(__props.event.argument), 1)
          ])
        ]),
        _: 1
      });
    };
  }
});
const _hoisted_1$i = { key: 1 };
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "StoryEvents",
  setup(__props) {
    const eventsStore = useEventsStore();
    const hasEvents = computed(() => eventsStore.events.length);
    onMounted(resetUnseen);
    watch(() => eventsStore.unseen, resetUnseen);
    async function resetUnseen() {
      if (eventsStore.unseen > 0) {
        eventsStore.unseen = 0;
      }
      await nextTick();
      eventsElement.value.scrollTo({ top: eventsElement.value.scrollHeight });
    }
    const eventsElement = ref();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "eventsElement",
        ref: eventsElement,
        class: "histoire-story-events"
      }, [
        !hasEvents.value ? (openBlock(), createBlock(BaseEmpty, { key: 0 }, {
          default: withCtx(() => [
            createVNode(unref(Icon), {
              icon: "carbon:event-schedule",
              class: "htw-w-8 htw-h-8 htw-opacity-50 htw-mb-6"
            }),
            _cache[0] || (_cache[0] = createTextVNode(" No event fired ", -1))
          ]),
          _: 1
        })) : (openBlock(), createElementBlock("div", _hoisted_1$i, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(eventsStore).events, (event, key) => {
            return openBlock(), createBlock(_sfc_main$l, {
              key,
              event
            }, null, 8, ["event"]);
          }), 128))
        ]))
      ], 512);
    };
  }
});
let ShikiError$2 = class ShikiError extends Error {
  constructor(message) {
    super(message);
    this.name = "ShikiError";
  }
};
function resolveColorReplacements(theme, options) {
  const replacements = typeof theme === "string" ? {} : { ...theme.colorReplacements };
  const themeName = typeof theme === "string" ? theme : theme.name;
  for (const [key, value] of Object.entries(options?.colorReplacements || {})) {
    if (typeof value === "string")
      replacements[key] = value;
    else if (key === themeName)
      Object.assign(replacements, value);
  }
  return replacements;
}
function applyColorReplacements(color, replacements) {
  if (!color)
    return color;
  return replacements?.[color?.toLowerCase()] || color;
}
function toArray(x) {
  return Array.isArray(x) ? x : [x];
}
async function normalizeGetter(p) {
  return Promise.resolve(typeof p === "function" ? p() : p).then((r) => r.default || r);
}
function isPlainLang(lang) {
  return !lang || ["plaintext", "txt", "text", "plain"].includes(lang);
}
function isSpecialLang(lang) {
  return lang === "ansi" || isPlainLang(lang);
}
function isNoneTheme(theme) {
  return theme === "none";
}
function isSpecialTheme(theme) {
  return isNoneTheme(theme);
}
function addClassToHast(node, className) {
  if (!className)
    return node;
  node.properties ||= {};
  node.properties.class ||= [];
  if (typeof node.properties.class === "string")
    node.properties.class = node.properties.class.split(/\s+/g);
  if (!Array.isArray(node.properties.class))
    node.properties.class = [];
  const targets = Array.isArray(className) ? className : className.split(/\s+/g);
  for (const c of targets) {
    if (c && !node.properties.class.includes(c))
      node.properties.class.push(c);
  }
  return node;
}
function splitLines(code, preserveEnding = false) {
  if (code.length === 0) {
    return [["", 0]];
  }
  const parts = code.split(/(\r?\n)/g);
  let index = 0;
  const lines = [];
  for (let i = 0; i < parts.length; i += 2) {
    const line = preserveEnding ? parts[i] + (parts[i + 1] || "") : parts[i];
    lines.push([line, index]);
    index += parts[i].length;
    index += parts[i + 1]?.length || 0;
  }
  return lines;
}
function createPositionConverter(code) {
  const lines = splitLines(code, true).map(([line]) => line);
  function indexToPos(index) {
    if (index === code.length) {
      return {
        line: lines.length - 1,
        character: lines[lines.length - 1].length
      };
    }
    let character = index;
    let line = 0;
    for (const lineText of lines) {
      if (character < lineText.length)
        break;
      character -= lineText.length;
      line++;
    }
    return { line, character };
  }
  function posToIndex(line, character) {
    let index = 0;
    for (let i = 0; i < line; i++)
      index += lines[i].length;
    index += character;
    return index;
  }
  return {
    lines,
    indexToPos,
    posToIndex
  };
}
const DEFAULT_COLOR_LIGHT_DARK = "light-dark()";
const COLOR_KEYS = ["color", "background-color"];
function splitToken(token, offsets) {
  let lastOffset = 0;
  const tokens = [];
  for (const offset of offsets) {
    if (offset > lastOffset) {
      tokens.push({
        ...token,
        content: token.content.slice(lastOffset, offset),
        offset: token.offset + lastOffset
      });
    }
    lastOffset = offset;
  }
  if (lastOffset < token.content.length) {
    tokens.push({
      ...token,
      content: token.content.slice(lastOffset),
      offset: token.offset + lastOffset
    });
  }
  return tokens;
}
function splitTokens(tokens, breakpoints) {
  const sorted = Array.from(breakpoints instanceof Set ? breakpoints : new Set(breakpoints)).sort((a, b) => a - b);
  if (!sorted.length)
    return tokens;
  return tokens.map((line) => {
    return line.flatMap((token) => {
      const breakpointsInToken = sorted.filter((i) => token.offset < i && i < token.offset + token.content.length).map((i) => i - token.offset).sort((a, b) => a - b);
      if (!breakpointsInToken.length)
        return token;
      return splitToken(token, breakpointsInToken);
    });
  });
}
function flatTokenVariants(merged, variantsOrder, cssVariablePrefix, defaultColor, colorsRendering = "css-vars") {
  const token = {
    content: merged.content,
    explanation: merged.explanation,
    offset: merged.offset
  };
  const styles = variantsOrder.map((t) => getTokenStyleObject(merged.variants[t]));
  const styleKeys = new Set(styles.flatMap((t) => Object.keys(t)));
  const mergedStyles = {};
  const varKey = (idx, key) => {
    const keyName = key === "color" ? "" : key === "background-color" ? "-bg" : `-${key}`;
    return cssVariablePrefix + variantsOrder[idx] + (key === "color" ? "" : keyName);
  };
  styles.forEach((cur, idx) => {
    for (const key of styleKeys) {
      const value = cur[key] || "inherit";
      if (idx === 0 && defaultColor && COLOR_KEYS.includes(key)) {
        if (defaultColor === DEFAULT_COLOR_LIGHT_DARK && styles.length > 1) {
          const lightIndex = variantsOrder.findIndex((t) => t === "light");
          const darkIndex = variantsOrder.findIndex((t) => t === "dark");
          if (lightIndex === -1 || darkIndex === -1)
            throw new ShikiError$2('When using `defaultColor: "light-dark()"`, you must provide both `light` and `dark` themes');
          const lightValue = styles[lightIndex][key] || "inherit";
          const darkValue = styles[darkIndex][key] || "inherit";
          mergedStyles[key] = `light-dark(${lightValue}, ${darkValue})`;
          if (colorsRendering === "css-vars")
            mergedStyles[varKey(idx, key)] = value;
        } else {
          mergedStyles[key] = value;
        }
      } else {
        if (colorsRendering === "css-vars")
          mergedStyles[varKey(idx, key)] = value;
      }
    }
  });
  token.htmlStyle = mergedStyles;
  return token;
}
function getTokenStyleObject(token) {
  const styles = {};
  if (token.color)
    styles.color = token.color;
  if (token.bgColor)
    styles["background-color"] = token.bgColor;
  if (token.fontStyle) {
    if (token.fontStyle & FontStyle.Italic)
      styles["font-style"] = "italic";
    if (token.fontStyle & FontStyle.Bold)
      styles["font-weight"] = "bold";
    const decorations2 = [];
    if (token.fontStyle & FontStyle.Underline)
      decorations2.push("underline");
    if (token.fontStyle & FontStyle.Strikethrough)
      decorations2.push("line-through");
    if (decorations2.length)
      styles["text-decoration"] = decorations2.join(" ");
  }
  return styles;
}
function stringifyTokenStyle(token) {
  if (typeof token === "string")
    return token;
  return Object.entries(token).map(([key, value]) => `${key}:${value}`).join(";");
}
const _grammarStateMap = /* @__PURE__ */ new WeakMap();
function setLastGrammarStateToMap(keys, state) {
  _grammarStateMap.set(keys, state);
}
function getLastGrammarStateFromMap(keys) {
  return _grammarStateMap.get(keys);
}
class GrammarState {
  /**
   * Theme to Stack mapping
   */
  _stacks = {};
  lang;
  get themes() {
    return Object.keys(this._stacks);
  }
  get theme() {
    return this.themes[0];
  }
  get _stack() {
    return this._stacks[this.theme];
  }
  /**
   * Static method to create a initial grammar state.
   */
  static initial(lang, themes) {
    return new GrammarState(
      Object.fromEntries(toArray(themes).map((theme) => [theme, INITIAL])),
      lang
    );
  }
  constructor(...args) {
    if (args.length === 2) {
      const [stacksMap, lang] = args;
      this.lang = lang;
      this._stacks = stacksMap;
    } else {
      const [stack, lang, theme] = args;
      this.lang = lang;
      this._stacks = { [theme]: stack };
    }
  }
  /**
   * Get the internal stack object.
   * @internal
   */
  getInternalStack(theme = this.theme) {
    return this._stacks[theme];
  }
  getScopes(theme = this.theme) {
    return getScopes(this._stacks[theme]);
  }
  toJSON() {
    return {
      lang: this.lang,
      theme: this.theme,
      themes: this.themes,
      scopes: this.getScopes()
    };
  }
}
function getScopes(stack) {
  const scopes = [];
  const visited = /* @__PURE__ */ new Set();
  function pushScope(stack2) {
    if (visited.has(stack2))
      return;
    visited.add(stack2);
    const name = stack2?.nameScopesList?.scopeName;
    if (name)
      scopes.push(name);
    if (stack2.parent)
      pushScope(stack2.parent);
  }
  pushScope(stack);
  return scopes;
}
function getGrammarStack(state, theme) {
  if (!(state instanceof GrammarState))
    throw new ShikiError$2("Invalid grammar state");
  return state.getInternalStack(theme);
}
function transformerDecorations() {
  const map = /* @__PURE__ */ new WeakMap();
  function getContext(shiki) {
    if (!map.has(shiki.meta)) {
      let normalizePosition = function(p) {
        if (typeof p === "number") {
          if (p < 0 || p > shiki.source.length)
            throw new ShikiError$2(`Invalid decoration offset: ${p}. Code length: ${shiki.source.length}`);
          return {
            ...converter.indexToPos(p),
            offset: p
          };
        } else {
          const line = converter.lines[p.line];
          if (line === void 0)
            throw new ShikiError$2(`Invalid decoration position ${JSON.stringify(p)}. Lines length: ${converter.lines.length}`);
          let character = p.character;
          if (character < 0)
            character = line.length + character;
          if (character < 0 || character > line.length)
            throw new ShikiError$2(`Invalid decoration position ${JSON.stringify(p)}. Line ${p.line} length: ${line.length}`);
          return {
            ...p,
            character,
            offset: converter.posToIndex(p.line, character)
          };
        }
      };
      const converter = createPositionConverter(shiki.source);
      const decorations2 = (shiki.options.decorations || []).map((d) => ({
        ...d,
        start: normalizePosition(d.start),
        end: normalizePosition(d.end)
      }));
      verifyIntersections(decorations2);
      map.set(shiki.meta, {
        decorations: decorations2,
        converter,
        source: shiki.source
      });
    }
    return map.get(shiki.meta);
  }
  return {
    name: "shiki:decorations",
    tokens(tokens) {
      if (!this.options.decorations?.length)
        return;
      const ctx = getContext(this);
      const breakpoints = ctx.decorations.flatMap((d) => [d.start.offset, d.end.offset]);
      const splitted = splitTokens(tokens, breakpoints);
      return splitted;
    },
    code(codeEl) {
      if (!this.options.decorations?.length)
        return;
      const ctx = getContext(this);
      const lines = Array.from(codeEl.children).filter((i) => i.type === "element" && i.tagName === "span");
      if (lines.length !== ctx.converter.lines.length)
        throw new ShikiError$2(`Number of lines in code element (${lines.length}) does not match the number of lines in the source (${ctx.converter.lines.length}). Failed to apply decorations.`);
      function applyLineSection(line, start, end, decoration) {
        const lineEl = lines[line];
        let text = "";
        let startIndex = -1;
        let endIndex = -1;
        if (start === 0)
          startIndex = 0;
        if (end === 0)
          endIndex = 0;
        if (end === Number.POSITIVE_INFINITY)
          endIndex = lineEl.children.length;
        if (startIndex === -1 || endIndex === -1) {
          for (let i = 0; i < lineEl.children.length; i++) {
            text += stringify(lineEl.children[i]);
            if (startIndex === -1 && text.length === start)
              startIndex = i + 1;
            if (endIndex === -1 && text.length === end)
              endIndex = i + 1;
          }
        }
        if (startIndex === -1)
          throw new ShikiError$2(`Failed to find start index for decoration ${JSON.stringify(decoration.start)}`);
        if (endIndex === -1)
          throw new ShikiError$2(`Failed to find end index for decoration ${JSON.stringify(decoration.end)}`);
        const children = lineEl.children.slice(startIndex, endIndex);
        if (!decoration.alwaysWrap && children.length === lineEl.children.length) {
          applyDecoration(lineEl, decoration, "line");
        } else if (!decoration.alwaysWrap && children.length === 1 && children[0].type === "element") {
          applyDecoration(children[0], decoration, "token");
        } else {
          const wrapper = {
            type: "element",
            tagName: "span",
            properties: {},
            children
          };
          applyDecoration(wrapper, decoration, "wrapper");
          lineEl.children.splice(startIndex, children.length, wrapper);
        }
      }
      function applyLine(line, decoration) {
        lines[line] = applyDecoration(lines[line], decoration, "line");
      }
      function applyDecoration(el, decoration, type) {
        const properties = decoration.properties || {};
        const transform = decoration.transform || ((i) => i);
        el.tagName = decoration.tagName || "span";
        el.properties = {
          ...el.properties,
          ...properties,
          class: el.properties.class
        };
        if (decoration.properties?.class)
          addClassToHast(el, decoration.properties.class);
        el = transform(el, type) || el;
        return el;
      }
      const lineApplies = [];
      const sorted = ctx.decorations.sort((a, b) => b.start.offset - a.start.offset || a.end.offset - b.end.offset);
      for (const decoration of sorted) {
        const { start, end } = decoration;
        if (start.line === end.line) {
          applyLineSection(start.line, start.character, end.character, decoration);
        } else if (start.line < end.line) {
          applyLineSection(start.line, start.character, Number.POSITIVE_INFINITY, decoration);
          for (let i = start.line + 1; i < end.line; i++)
            lineApplies.unshift(() => applyLine(i, decoration));
          applyLineSection(end.line, 0, end.character, decoration);
        }
      }
      lineApplies.forEach((i) => i());
    }
  };
}
function verifyIntersections(items) {
  for (let i = 0; i < items.length; i++) {
    const foo = items[i];
    if (foo.start.offset > foo.end.offset)
      throw new ShikiError$2(`Invalid decoration range: ${JSON.stringify(foo.start)} - ${JSON.stringify(foo.end)}`);
    for (let j = i + 1; j < items.length; j++) {
      const bar = items[j];
      const isFooHasBarStart = foo.start.offset <= bar.start.offset && bar.start.offset < foo.end.offset;
      const isFooHasBarEnd = foo.start.offset < bar.end.offset && bar.end.offset <= foo.end.offset;
      const isBarHasFooStart = bar.start.offset <= foo.start.offset && foo.start.offset < bar.end.offset;
      const isBarHasFooEnd = bar.start.offset < foo.end.offset && foo.end.offset <= bar.end.offset;
      if (isFooHasBarStart || isFooHasBarEnd || isBarHasFooStart || isBarHasFooEnd) {
        if (isFooHasBarStart && isFooHasBarEnd)
          continue;
        if (isBarHasFooStart && isBarHasFooEnd)
          continue;
        if (isBarHasFooStart && foo.start.offset === foo.end.offset)
          continue;
        if (isFooHasBarEnd && bar.start.offset === bar.end.offset)
          continue;
        throw new ShikiError$2(`Decorations ${JSON.stringify(foo.start)} and ${JSON.stringify(bar.start)} intersect.`);
      }
    }
  }
}
function stringify(el) {
  if (el.type === "text")
    return el.value;
  if (el.type === "element")
    return el.children.map(stringify).join("");
  return "";
}
const builtInTransformers = [
  /* @__PURE__ */ transformerDecorations()
];
function getTransformers(options) {
  const transformers = sortTransformersByEnforcement(options.transformers || []);
  return [
    ...transformers.pre,
    ...transformers.normal,
    ...transformers.post,
    ...builtInTransformers
  ];
}
function sortTransformersByEnforcement(transformers) {
  const pre = [];
  const post = [];
  const normal = [];
  for (const transformer of transformers) {
    switch (transformer.enforce) {
      case "pre":
        pre.push(transformer);
        break;
      case "post":
        post.push(transformer);
        break;
      default:
        normal.push(transformer);
    }
  }
  return { pre, post, normal };
}
var namedColors = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
];
var decorations = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  8: "hidden",
  9: "strikethrough"
};
function findSequence(value, position) {
  const nextEscape = value.indexOf("\x1B", position);
  if (nextEscape !== -1) {
    if (value[nextEscape + 1] === "[") {
      const nextClose = value.indexOf("m", nextEscape);
      if (nextClose !== -1) {
        return {
          sequence: value.substring(nextEscape + 2, nextClose).split(";"),
          startPosition: nextEscape,
          position: nextClose + 1
        };
      }
    }
  }
  return {
    position: value.length
  };
}
function parseColor(sequence) {
  const colorMode = sequence.shift();
  if (colorMode === "2") {
    const rgb = sequence.splice(0, 3).map((x) => Number.parseInt(x));
    if (rgb.length !== 3 || rgb.some((x) => Number.isNaN(x)))
      return;
    return {
      type: "rgb",
      rgb
    };
  } else if (colorMode === "5") {
    const index = sequence.shift();
    if (index) {
      return { type: "table", index: Number(index) };
    }
  }
}
function parseSequence(sequence) {
  const commands = [];
  while (sequence.length > 0) {
    const code = sequence.shift();
    if (!code)
      continue;
    const codeInt = Number.parseInt(code);
    if (Number.isNaN(codeInt))
      continue;
    if (codeInt === 0) {
      commands.push({ type: "resetAll" });
    } else if (codeInt <= 9) {
      const decoration = decorations[codeInt];
      if (decoration) {
        commands.push({
          type: "setDecoration",
          value: decorations[codeInt]
        });
      }
    } else if (codeInt <= 29) {
      const decoration = decorations[codeInt - 20];
      if (decoration) {
        commands.push({
          type: "resetDecoration",
          value: decoration
        });
        if (decoration === "dim") {
          commands.push({
            type: "resetDecoration",
            value: "bold"
          });
        }
      }
    } else if (codeInt <= 37) {
      commands.push({
        type: "setForegroundColor",
        value: { type: "named", name: namedColors[codeInt - 30] }
      });
    } else if (codeInt === 38) {
      const color = parseColor(sequence);
      if (color) {
        commands.push({
          type: "setForegroundColor",
          value: color
        });
      }
    } else if (codeInt === 39) {
      commands.push({
        type: "resetForegroundColor"
      });
    } else if (codeInt <= 47) {
      commands.push({
        type: "setBackgroundColor",
        value: { type: "named", name: namedColors[codeInt - 40] }
      });
    } else if (codeInt === 48) {
      const color = parseColor(sequence);
      if (color) {
        commands.push({
          type: "setBackgroundColor",
          value: color
        });
      }
    } else if (codeInt === 49) {
      commands.push({
        type: "resetBackgroundColor"
      });
    } else if (codeInt === 53) {
      commands.push({
        type: "setDecoration",
        value: "overline"
      });
    } else if (codeInt === 55) {
      commands.push({
        type: "resetDecoration",
        value: "overline"
      });
    } else if (codeInt >= 90 && codeInt <= 97) {
      commands.push({
        type: "setForegroundColor",
        value: { type: "named", name: namedColors[codeInt - 90 + 8] }
      });
    } else if (codeInt >= 100 && codeInt <= 107) {
      commands.push({
        type: "setBackgroundColor",
        value: { type: "named", name: namedColors[codeInt - 100 + 8] }
      });
    }
  }
  return commands;
}
function createAnsiSequenceParser() {
  let foreground = null;
  let background = null;
  let decorations2 = /* @__PURE__ */ new Set();
  return {
    parse(value) {
      const tokens = [];
      let position = 0;
      do {
        const findResult = findSequence(value, position);
        const text = findResult.sequence ? value.substring(position, findResult.startPosition) : value.substring(position);
        if (text.length > 0) {
          tokens.push({
            value: text,
            foreground,
            background,
            decorations: new Set(decorations2)
          });
        }
        if (findResult.sequence) {
          const commands = parseSequence(findResult.sequence);
          for (const styleToken of commands) {
            if (styleToken.type === "resetAll") {
              foreground = null;
              background = null;
              decorations2.clear();
            } else if (styleToken.type === "resetForegroundColor") {
              foreground = null;
            } else if (styleToken.type === "resetBackgroundColor") {
              background = null;
            } else if (styleToken.type === "resetDecoration") {
              decorations2.delete(styleToken.value);
            }
          }
          for (const styleToken of commands) {
            if (styleToken.type === "setForegroundColor") {
              foreground = styleToken.value;
            } else if (styleToken.type === "setBackgroundColor") {
              background = styleToken.value;
            } else if (styleToken.type === "setDecoration") {
              decorations2.add(styleToken.value);
            }
          }
        }
        position = findResult.position;
      } while (position < value.length);
      return tokens;
    }
  };
}
var defaultNamedColorsMap = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function createColorPalette(namedColorsMap = defaultNamedColorsMap) {
  function namedColor(name) {
    return namedColorsMap[name];
  }
  function rgbColor(rgb) {
    return `#${rgb.map((x) => Math.max(0, Math.min(x, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let colorTable;
  function getColorTable() {
    if (colorTable) {
      return colorTable;
    }
    colorTable = [];
    for (let i = 0; i < namedColors.length; i++) {
      colorTable.push(namedColor(namedColors[i]));
    }
    let levels = [0, 95, 135, 175, 215, 255];
    for (let r = 0; r < 6; r++) {
      for (let g = 0; g < 6; g++) {
        for (let b = 0; b < 6; b++) {
          colorTable.push(rgbColor([levels[r], levels[g], levels[b]]));
        }
      }
    }
    let level = 8;
    for (let i = 0; i < 24; i++, level += 10) {
      colorTable.push(rgbColor([level, level, level]));
    }
    return colorTable;
  }
  function tableColor(index) {
    return getColorTable()[index];
  }
  function value(color) {
    switch (color.type) {
      case "named":
        return namedColor(color.name);
      case "rgb":
        return rgbColor(color.rgb);
      case "table":
        return tableColor(color.index);
    }
  }
  return {
    value
  };
}
const defaultAnsiColors = {
  black: "#000000",
  red: "#cd3131",
  green: "#0DBC79",
  yellow: "#E5E510",
  blue: "#2472C8",
  magenta: "#BC3FBC",
  cyan: "#11A8CD",
  white: "#E5E5E5",
  brightBlack: "#666666",
  brightRed: "#F14C4C",
  brightGreen: "#23D18B",
  brightYellow: "#F5F543",
  brightBlue: "#3B8EEA",
  brightMagenta: "#D670D6",
  brightCyan: "#29B8DB",
  brightWhite: "#FFFFFF"
};
function tokenizeAnsiWithTheme(theme, fileContents, options) {
  const colorReplacements = resolveColorReplacements(theme, options);
  const lines = splitLines(fileContents);
  const ansiPalette = Object.fromEntries(
    namedColors.map((name) => {
      const key = `terminal.ansi${name[0].toUpperCase()}${name.substring(1)}`;
      const themeColor = theme.colors?.[key];
      return [name, themeColor || defaultAnsiColors[name]];
    })
  );
  const colorPalette = createColorPalette(ansiPalette);
  const parser = createAnsiSequenceParser();
  return lines.map(
    (line) => parser.parse(line[0]).map((token) => {
      let color;
      let bgColor;
      if (token.decorations.has("reverse")) {
        color = token.background ? colorPalette.value(token.background) : theme.bg;
        bgColor = token.foreground ? colorPalette.value(token.foreground) : theme.fg;
      } else {
        color = token.foreground ? colorPalette.value(token.foreground) : theme.fg;
        bgColor = token.background ? colorPalette.value(token.background) : void 0;
      }
      color = applyColorReplacements(color, colorReplacements);
      bgColor = applyColorReplacements(bgColor, colorReplacements);
      if (token.decorations.has("dim"))
        color = dimColor(color);
      let fontStyle = FontStyle.None;
      if (token.decorations.has("bold"))
        fontStyle |= FontStyle.Bold;
      if (token.decorations.has("italic"))
        fontStyle |= FontStyle.Italic;
      if (token.decorations.has("underline"))
        fontStyle |= FontStyle.Underline;
      if (token.decorations.has("strikethrough"))
        fontStyle |= FontStyle.Strikethrough;
      return {
        content: token.value,
        offset: line[1],
        // TODO: more accurate offset? might need to fork ansi-sequence-parser
        color,
        bgColor,
        fontStyle
      };
    })
  );
}
function dimColor(color) {
  const hexMatch = color.match(/#([0-9a-f]{3,8})/i);
  if (hexMatch) {
    const hex = hexMatch[1];
    if (hex.length === 8) {
      const alpha = Math.round(Number.parseInt(hex.slice(6, 8), 16) / 2).toString(16).padStart(2, "0");
      return `#${hex.slice(0, 6)}${alpha}`;
    } else if (hex.length === 6) {
      return `#${hex}80`;
    } else if (hex.length === 4) {
      const r = hex[0];
      const g = hex[1];
      const b = hex[2];
      const a = hex[3];
      const alpha = Math.round(Number.parseInt(`${a}${a}`, 16) / 2).toString(16).padStart(2, "0");
      return `#${r}${r}${g}${g}${b}${b}${alpha}`;
    } else if (hex.length === 3) {
      const r = hex[0];
      const g = hex[1];
      const b = hex[2];
      return `#${r}${r}${g}${g}${b}${b}80`;
    }
  }
  const cssVarMatch = color.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
  if (cssVarMatch)
    return `var(${cssVarMatch[1]}-dim)`;
  return color;
}
function codeToTokensBase(internal, code, options = {}) {
  const {
    theme: themeName = internal.getLoadedThemes()[0]
  } = options;
  const lang = internal.resolveLangAlias(options.lang || "text");
  if (isPlainLang(lang) || isNoneTheme(themeName))
    return splitLines(code).map((line) => [{ content: line[0], offset: line[1] }]);
  const { theme, colorMap } = internal.setTheme(themeName);
  if (lang === "ansi")
    return tokenizeAnsiWithTheme(theme, code, options);
  const _grammar = internal.getLanguage(options.lang || "text");
  if (options.grammarState) {
    if (options.grammarState.lang !== _grammar.name) {
      throw new ShikiError$2(`Grammar state language "${options.grammarState.lang}" does not match highlight language "${_grammar.name}"`);
    }
    if (!options.grammarState.themes.includes(theme.name)) {
      throw new ShikiError$2(`Grammar state themes "${options.grammarState.themes}" do not contain highlight theme "${theme.name}"`);
    }
  }
  return tokenizeWithTheme(code, _grammar, theme, colorMap, options);
}
function getLastGrammarState(...args) {
  if (args.length === 2) {
    return getLastGrammarStateFromMap(args[1]);
  }
  const [internal, code, options = {}] = args;
  const {
    lang = "text",
    theme: themeName = internal.getLoadedThemes()[0]
  } = options;
  if (isPlainLang(lang) || isNoneTheme(themeName))
    throw new ShikiError$2("Plain language does not have grammar state");
  if (lang === "ansi")
    throw new ShikiError$2("ANSI language does not have grammar state");
  const { theme, colorMap } = internal.setTheme(themeName);
  const _grammar = internal.getLanguage(lang);
  return new GrammarState(
    _tokenizeWithTheme(code, _grammar, theme, colorMap, options).stateStack,
    _grammar.name,
    theme.name
  );
}
function tokenizeWithTheme(code, grammar, theme, colorMap, options) {
  const result = _tokenizeWithTheme(code, grammar, theme, colorMap, options);
  const grammarState = new GrammarState(
    result.stateStack,
    grammar.name,
    theme.name
  );
  setLastGrammarStateToMap(result.tokens, grammarState);
  return result.tokens;
}
function _tokenizeWithTheme(code, grammar, theme, colorMap, options) {
  const colorReplacements = resolveColorReplacements(theme, options);
  const {
    tokenizeMaxLineLength = 0,
    tokenizeTimeLimit = 500
  } = options;
  const lines = splitLines(code);
  let stateStack = options.grammarState ? getGrammarStack(options.grammarState, theme.name) ?? INITIAL : options.grammarContextCode != null ? _tokenizeWithTheme(
    options.grammarContextCode,
    grammar,
    theme,
    colorMap,
    {
      ...options,
      grammarState: void 0,
      grammarContextCode: void 0
    }
  ).stateStack : INITIAL;
  let actual = [];
  const final = [];
  for (let i = 0, len = lines.length; i < len; i++) {
    const [line, lineOffset] = lines[i];
    if (line === "") {
      actual = [];
      final.push([]);
      continue;
    }
    if (tokenizeMaxLineLength > 0 && line.length >= tokenizeMaxLineLength) {
      actual = [];
      final.push([{
        content: line,
        offset: lineOffset,
        color: "",
        fontStyle: 0
      }]);
      continue;
    }
    let resultWithScopes;
    let tokensWithScopes;
    let tokensWithScopesIndex;
    if (options.includeExplanation) {
      resultWithScopes = grammar.tokenizeLine(line, stateStack, tokenizeTimeLimit);
      tokensWithScopes = resultWithScopes.tokens;
      tokensWithScopesIndex = 0;
    }
    const result = grammar.tokenizeLine2(line, stateStack, tokenizeTimeLimit);
    const tokensLength = result.tokens.length / 2;
    for (let j = 0; j < tokensLength; j++) {
      const startIndex = result.tokens[2 * j];
      const nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;
      if (startIndex === nextStartIndex)
        continue;
      const metadata = result.tokens[2 * j + 1];
      const color = applyColorReplacements(
        colorMap[EncodedTokenMetadata.getForeground(metadata)],
        colorReplacements
      );
      const fontStyle = EncodedTokenMetadata.getFontStyle(metadata);
      const token = {
        content: line.substring(startIndex, nextStartIndex),
        offset: lineOffset + startIndex,
        color,
        fontStyle
      };
      if (options.includeExplanation) {
        const themeSettingsSelectors = [];
        if (options.includeExplanation !== "scopeName") {
          for (const setting of theme.settings) {
            let selectors;
            switch (typeof setting.scope) {
              case "string":
                selectors = setting.scope.split(/,/).map((scope) => scope.trim());
                break;
              case "object":
                selectors = setting.scope;
                break;
              default:
                continue;
            }
            themeSettingsSelectors.push({
              settings: setting,
              selectors: selectors.map((selector) => selector.split(/ /))
            });
          }
        }
        token.explanation = [];
        let offset = 0;
        while (startIndex + offset < nextStartIndex) {
          const tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];
          const tokenWithScopesText = line.substring(
            tokenWithScopes.startIndex,
            tokenWithScopes.endIndex
          );
          offset += tokenWithScopesText.length;
          token.explanation.push({
            content: tokenWithScopesText,
            scopes: options.includeExplanation === "scopeName" ? explainThemeScopesNameOnly(
              tokenWithScopes.scopes
            ) : explainThemeScopesFull(
              themeSettingsSelectors,
              tokenWithScopes.scopes
            )
          });
          tokensWithScopesIndex += 1;
        }
      }
      actual.push(token);
    }
    final.push(actual);
    actual = [];
    stateStack = result.ruleStack;
  }
  return {
    tokens: final,
    stateStack
  };
}
function explainThemeScopesNameOnly(scopes) {
  return scopes.map((scope) => ({ scopeName: scope }));
}
function explainThemeScopesFull(themeSelectors, scopes) {
  const result = [];
  for (let i = 0, len = scopes.length; i < len; i++) {
    const scope = scopes[i];
    result[i] = {
      scopeName: scope,
      themeMatches: explainThemeScope(themeSelectors, scope, scopes.slice(0, i))
    };
  }
  return result;
}
function matchesOne(selector, scope) {
  return selector === scope || scope.substring(0, selector.length) === selector && scope[selector.length] === ".";
}
function matches(selectors, scope, parentScopes) {
  if (!matchesOne(selectors[selectors.length - 1], scope))
    return false;
  let selectorParentIndex = selectors.length - 2;
  let parentIndex = parentScopes.length - 1;
  while (selectorParentIndex >= 0 && parentIndex >= 0) {
    if (matchesOne(selectors[selectorParentIndex], parentScopes[parentIndex]))
      selectorParentIndex -= 1;
    parentIndex -= 1;
  }
  if (selectorParentIndex === -1)
    return true;
  return false;
}
function explainThemeScope(themeSettingsSelectors, scope, parentScopes) {
  const result = [];
  for (const { selectors, settings } of themeSettingsSelectors) {
    for (const selectorPieces of selectors) {
      if (matches(selectorPieces, scope, parentScopes)) {
        result.push(settings);
        break;
      }
    }
  }
  return result;
}
function codeToTokensWithThemes(internal, code, options) {
  const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] }));
  const themedTokens = themes.map((t) => {
    const tokens2 = codeToTokensBase(internal, code, {
      ...options,
      theme: t.theme
    });
    const state = getLastGrammarStateFromMap(tokens2);
    const theme = typeof t.theme === "string" ? t.theme : t.theme.name;
    return {
      tokens: tokens2,
      state,
      theme
    };
  });
  const tokens = syncThemesTokenization(
    ...themedTokens.map((i) => i.tokens)
  );
  const mergedTokens = tokens[0].map(
    (line, lineIdx) => line.map((_token, tokenIdx) => {
      const mergedToken = {
        content: _token.content,
        variants: {},
        offset: _token.offset
      };
      if ("includeExplanation" in options && options.includeExplanation) {
        mergedToken.explanation = _token.explanation;
      }
      tokens.forEach((t, themeIdx) => {
        const {
          content: _,
          explanation: __,
          offset: ___,
          ...styles
        } = t[lineIdx][tokenIdx];
        mergedToken.variants[themes[themeIdx].color] = styles;
      });
      return mergedToken;
    })
  );
  const mergedGrammarState = themedTokens[0].state ? new GrammarState(
    Object.fromEntries(themedTokens.map((s) => [s.theme, s.state?.getInternalStack(s.theme)])),
    themedTokens[0].state.lang
  ) : void 0;
  if (mergedGrammarState)
    setLastGrammarStateToMap(mergedTokens, mergedGrammarState);
  return mergedTokens;
}
function syncThemesTokenization(...themes) {
  const outThemes = themes.map(() => []);
  const count = themes.length;
  for (let i = 0; i < themes[0].length; i++) {
    const lines = themes.map((t) => t[i]);
    const outLines = outThemes.map(() => []);
    outThemes.forEach((t, i2) => t.push(outLines[i2]));
    const indexes = lines.map(() => 0);
    const current = lines.map((l) => l[0]);
    while (current.every((t) => t)) {
      const minLength = Math.min(...current.map((t) => t.content.length));
      for (let n = 0; n < count; n++) {
        const token = current[n];
        if (token.content.length === minLength) {
          outLines[n].push(token);
          indexes[n] += 1;
          current[n] = lines[n][indexes[n]];
        } else {
          outLines[n].push({
            ...token,
            content: token.content.slice(0, minLength)
          });
          current[n] = {
            ...token,
            content: token.content.slice(minLength),
            offset: token.offset + minLength
          };
        }
      }
    }
  }
  return outThemes;
}
function codeToTokens(internal, code, options) {
  let bg;
  let fg;
  let tokens;
  let themeName;
  let rootStyle;
  let grammarState;
  if ("themes" in options) {
    const {
      defaultColor = "light",
      cssVariablePrefix = "--shiki-",
      colorsRendering = "css-vars"
    } = options;
    const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] })).sort((a, b) => a.color === defaultColor ? -1 : b.color === defaultColor ? 1 : 0);
    if (themes.length === 0)
      throw new ShikiError$2("`themes` option must not be empty");
    const themeTokens = codeToTokensWithThemes(
      internal,
      code,
      options
    );
    grammarState = getLastGrammarStateFromMap(themeTokens);
    if (defaultColor && DEFAULT_COLOR_LIGHT_DARK !== defaultColor && !themes.find((t) => t.color === defaultColor))
      throw new ShikiError$2(`\`themes\` option must contain the defaultColor key \`${defaultColor}\``);
    const themeRegs = themes.map((t) => internal.getTheme(t.theme));
    const themesOrder = themes.map((t) => t.color);
    tokens = themeTokens.map((line) => line.map((token) => flatTokenVariants(token, themesOrder, cssVariablePrefix, defaultColor, colorsRendering)));
    if (grammarState)
      setLastGrammarStateToMap(tokens, grammarState);
    const themeColorReplacements = themes.map((t) => resolveColorReplacements(t.theme, options));
    fg = mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, "fg", colorsRendering);
    bg = mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, "bg", colorsRendering);
    themeName = `shiki-themes ${themeRegs.map((t) => t.name).join(" ")}`;
    rootStyle = defaultColor ? void 0 : [fg, bg].join(";");
  } else if ("theme" in options) {
    const colorReplacements = resolveColorReplacements(options.theme, options);
    tokens = codeToTokensBase(
      internal,
      code,
      options
    );
    const _theme = internal.getTheme(options.theme);
    bg = applyColorReplacements(_theme.bg, colorReplacements);
    fg = applyColorReplacements(_theme.fg, colorReplacements);
    themeName = _theme.name;
    grammarState = getLastGrammarStateFromMap(tokens);
  } else {
    throw new ShikiError$2("Invalid options, either `theme` or `themes` must be provided");
  }
  return {
    tokens,
    fg,
    bg,
    themeName,
    rootStyle,
    grammarState
  };
}
function mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, property, colorsRendering) {
  return themes.map((t, idx) => {
    const value = applyColorReplacements(themeRegs[idx][property], themeColorReplacements[idx]) || "inherit";
    const cssVar = `${cssVariablePrefix + t.color}${property === "bg" ? "-bg" : ""}:${value}`;
    if (idx === 0 && defaultColor) {
      if (defaultColor === DEFAULT_COLOR_LIGHT_DARK && themes.length > 1) {
        const lightIndex = themes.findIndex((t2) => t2.color === "light");
        const darkIndex = themes.findIndex((t2) => t2.color === "dark");
        if (lightIndex === -1 || darkIndex === -1)
          throw new ShikiError$2('When using `defaultColor: "light-dark()"`, you must provide both `light` and `dark` themes');
        const lightValue = applyColorReplacements(themeRegs[lightIndex][property], themeColorReplacements[lightIndex]) || "inherit";
        const darkValue = applyColorReplacements(themeRegs[darkIndex][property], themeColorReplacements[darkIndex]) || "inherit";
        return `light-dark(${lightValue}, ${darkValue});${cssVar}`;
      }
      return value;
    }
    if (colorsRendering === "css-vars") {
      return cssVar;
    }
    return null;
  }).filter((i) => !!i).join(";");
}
function codeToHast(internal, code, options, transformerContext = {
  meta: {},
  options,
  codeToHast: (_code, _options) => codeToHast(internal, _code, _options),
  codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)
}) {
  let input = code;
  for (const transformer of getTransformers(options))
    input = transformer.preprocess?.call(transformerContext, input, options) || input;
  let {
    tokens,
    fg,
    bg,
    themeName,
    rootStyle,
    grammarState
  } = codeToTokens(internal, input, options);
  const {
    mergeWhitespaces = true,
    mergeSameStyleTokens = false
  } = options;
  if (mergeWhitespaces === true)
    tokens = mergeWhitespaceTokens(tokens);
  else if (mergeWhitespaces === "never")
    tokens = splitWhitespaceTokens(tokens);
  if (mergeSameStyleTokens) {
    tokens = mergeAdjacentStyledTokens(tokens);
  }
  const contextSource = {
    ...transformerContext,
    get source() {
      return input;
    }
  };
  for (const transformer of getTransformers(options))
    tokens = transformer.tokens?.call(contextSource, tokens) || tokens;
  return tokensToHast(
    tokens,
    {
      ...options,
      fg,
      bg,
      themeName,
      rootStyle: options.rootStyle === false ? false : options.rootStyle ?? rootStyle
    },
    contextSource,
    grammarState
  );
}
function tokensToHast(tokens, options, transformerContext, grammarState = getLastGrammarStateFromMap(tokens)) {
  const transformers = getTransformers(options);
  const lines = [];
  const root = {
    type: "root",
    children: []
  };
  const {
    structure = "classic",
    tabindex = "0"
  } = options;
  const properties = {
    class: `shiki ${options.themeName || ""}`
  };
  if (options.rootStyle !== false) {
    if (options.rootStyle != null)
      properties.style = options.rootStyle;
    else
      properties.style = `background-color:${options.bg};color:${options.fg}`;
  }
  if (tabindex !== false && tabindex != null)
    properties.tabindex = tabindex.toString();
  for (const [key, value] of Object.entries(options.meta || {})) {
    if (!key.startsWith("_"))
      properties[key] = value;
  }
  let preNode = {
    type: "element",
    tagName: "pre",
    properties,
    children: [],
    data: options.data
  };
  let codeNode = {
    type: "element",
    tagName: "code",
    properties: {},
    children: lines
  };
  const lineNodes = [];
  const context = {
    ...transformerContext,
    structure,
    addClassToHast,
    get source() {
      return transformerContext.source;
    },
    get tokens() {
      return tokens;
    },
    get options() {
      return options;
    },
    get root() {
      return root;
    },
    get pre() {
      return preNode;
    },
    get code() {
      return codeNode;
    },
    get lines() {
      return lineNodes;
    }
  };
  tokens.forEach((line, idx) => {
    if (idx) {
      if (structure === "inline")
        root.children.push({ type: "element", tagName: "br", properties: {}, children: [] });
      else if (structure === "classic")
        lines.push({ type: "text", value: "\n" });
    }
    let lineNode = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    };
    let col = 0;
    for (const token of line) {
      let tokenNode = {
        type: "element",
        tagName: "span",
        properties: {
          ...token.htmlAttrs
        },
        children: [{ type: "text", value: token.content }]
      };
      const style = stringifyTokenStyle(token.htmlStyle || getTokenStyleObject(token));
      if (style)
        tokenNode.properties.style = style;
      for (const transformer of transformers)
        tokenNode = transformer?.span?.call(context, tokenNode, idx + 1, col, lineNode, token) || tokenNode;
      if (structure === "inline")
        root.children.push(tokenNode);
      else if (structure === "classic")
        lineNode.children.push(tokenNode);
      col += token.content.length;
    }
    if (structure === "classic") {
      for (const transformer of transformers)
        lineNode = transformer?.line?.call(context, lineNode, idx + 1) || lineNode;
      lineNodes.push(lineNode);
      lines.push(lineNode);
    } else if (structure === "inline") {
      lineNodes.push(lineNode);
    }
  });
  if (structure === "classic") {
    for (const transformer of transformers)
      codeNode = transformer?.code?.call(context, codeNode) || codeNode;
    preNode.children.push(codeNode);
    for (const transformer of transformers)
      preNode = transformer?.pre?.call(context, preNode) || preNode;
    root.children.push(preNode);
  } else if (structure === "inline") {
    const syntheticLines = [];
    let currentLine = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    };
    for (const child of root.children) {
      if (child.type === "element" && child.tagName === "br") {
        syntheticLines.push(currentLine);
        currentLine = {
          type: "element",
          tagName: "span",
          properties: { class: "line" },
          children: []
        };
      } else if (child.type === "element" || child.type === "text") {
        currentLine.children.push(child);
      }
    }
    syntheticLines.push(currentLine);
    const syntheticCode = {
      type: "element",
      tagName: "code",
      properties: {},
      children: syntheticLines
    };
    let transformedCode = syntheticCode;
    for (const transformer of transformers)
      transformedCode = transformer?.code?.call(context, transformedCode) || transformedCode;
    root.children = [];
    for (let i = 0; i < transformedCode.children.length; i++) {
      if (i > 0)
        root.children.push({ type: "element", tagName: "br", properties: {}, children: [] });
      const line = transformedCode.children[i];
      if (line.type === "element")
        root.children.push(...line.children);
    }
  }
  let result = root;
  for (const transformer of transformers)
    result = transformer?.root?.call(context, result) || result;
  if (grammarState)
    setLastGrammarStateToMap(result, grammarState);
  return result;
}
function mergeWhitespaceTokens(tokens) {
  return tokens.map((line) => {
    const newLine = [];
    let carryOnContent = "";
    let firstOffset;
    line.forEach((token, idx) => {
      const isDecorated = token.fontStyle && (token.fontStyle & FontStyle.Underline || token.fontStyle & FontStyle.Strikethrough);
      const couldMerge = !isDecorated;
      if (couldMerge && token.content.match(/^\s+$/) && line[idx + 1]) {
        if (firstOffset === void 0)
          firstOffset = token.offset;
        carryOnContent += token.content;
      } else {
        if (carryOnContent) {
          if (couldMerge) {
            newLine.push({
              ...token,
              offset: firstOffset,
              content: carryOnContent + token.content
            });
          } else {
            newLine.push(
              {
                content: carryOnContent,
                offset: firstOffset
              },
              token
            );
          }
          firstOffset = void 0;
          carryOnContent = "";
        } else {
          newLine.push(token);
        }
      }
    });
    return newLine;
  });
}
function splitWhitespaceTokens(tokens) {
  return tokens.map((line) => {
    return line.flatMap((token) => {
      if (token.content.match(/^\s+$/))
        return token;
      const match = token.content.match(/^(\s*)(.*?)(\s*)$/);
      if (!match)
        return token;
      const [, leading, content, trailing] = match;
      if (!leading && !trailing)
        return token;
      const expanded = [{
        ...token,
        offset: token.offset + leading.length,
        content
      }];
      if (leading) {
        expanded.unshift({
          content: leading,
          offset: token.offset
        });
      }
      if (trailing) {
        expanded.push({
          content: trailing,
          offset: token.offset + leading.length + content.length
        });
      }
      return expanded;
    });
  });
}
function mergeAdjacentStyledTokens(tokens) {
  return tokens.map((line) => {
    const newLine = [];
    for (const token of line) {
      if (newLine.length === 0) {
        newLine.push({ ...token });
        continue;
      }
      const prevToken = newLine[newLine.length - 1];
      const prevStyle = stringifyTokenStyle(prevToken.htmlStyle || getTokenStyleObject(prevToken));
      const currentStyle = stringifyTokenStyle(token.htmlStyle || getTokenStyleObject(token));
      const isPrevDecorated = prevToken.fontStyle && (prevToken.fontStyle & FontStyle.Underline || prevToken.fontStyle & FontStyle.Strikethrough);
      const isDecorated = token.fontStyle && (token.fontStyle & FontStyle.Underline || token.fontStyle & FontStyle.Strikethrough);
      if (!isPrevDecorated && !isDecorated && prevStyle === currentStyle) {
        prevToken.content += token.content;
      } else {
        newLine.push({ ...token });
      }
    }
    return newLine;
  });
}
const hastToHtml = toHtml;
function codeToHtml(internal, code, options) {
  const context = {
    meta: {},
    options,
    codeToHast: (_code, _options) => codeToHast(internal, _code, _options),
    codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)
  };
  let result = hastToHtml(codeToHast(internal, code, options, context));
  for (const transformer of getTransformers(options))
    result = transformer.postprocess?.call(context, result, options) || result;
  return result;
}
const VSCODE_FALLBACK_EDITOR_FG = { light: "#333333", dark: "#bbbbbb" };
const VSCODE_FALLBACK_EDITOR_BG = { light: "#fffffe", dark: "#1e1e1e" };
const RESOLVED_KEY = "__shiki_resolved";
function normalizeTheme(rawTheme) {
  if (rawTheme?.[RESOLVED_KEY])
    return rawTheme;
  const theme = {
    ...rawTheme
  };
  if (theme.tokenColors && !theme.settings) {
    theme.settings = theme.tokenColors;
    delete theme.tokenColors;
  }
  theme.type ||= "dark";
  theme.colorReplacements = { ...theme.colorReplacements };
  theme.settings ||= [];
  let { bg, fg } = theme;
  if (!bg || !fg) {
    const globalSetting = theme.settings ? theme.settings.find((s) => !s.name && !s.scope) : void 0;
    if (globalSetting?.settings?.foreground)
      fg = globalSetting.settings.foreground;
    if (globalSetting?.settings?.background)
      bg = globalSetting.settings.background;
    if (!fg && theme?.colors?.["editor.foreground"])
      fg = theme.colors["editor.foreground"];
    if (!bg && theme?.colors?.["editor.background"])
      bg = theme.colors["editor.background"];
    if (!fg)
      fg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;
    if (!bg)
      bg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;
    theme.fg = fg;
    theme.bg = bg;
  }
  if (!(theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope)) {
    theme.settings.unshift({
      settings: {
        foreground: theme.fg,
        background: theme.bg
      }
    });
  }
  let replacementCount = 0;
  const replacementMap = /* @__PURE__ */ new Map();
  function getReplacementColor(value) {
    if (replacementMap.has(value))
      return replacementMap.get(value);
    replacementCount += 1;
    const hex = `#${replacementCount.toString(16).padStart(8, "0").toLowerCase()}`;
    if (theme.colorReplacements?.[`#${hex}`])
      return getReplacementColor(value);
    replacementMap.set(value, hex);
    return hex;
  }
  theme.settings = theme.settings.map((setting) => {
    const replaceFg = setting.settings?.foreground && !setting.settings.foreground.startsWith("#");
    const replaceBg = setting.settings?.background && !setting.settings.background.startsWith("#");
    if (!replaceFg && !replaceBg)
      return setting;
    const clone2 = {
      ...setting,
      settings: {
        ...setting.settings
      }
    };
    if (replaceFg) {
      const replacement = getReplacementColor(setting.settings.foreground);
      theme.colorReplacements[replacement] = setting.settings.foreground;
      clone2.settings.foreground = replacement;
    }
    if (replaceBg) {
      const replacement = getReplacementColor(setting.settings.background);
      theme.colorReplacements[replacement] = setting.settings.background;
      clone2.settings.background = replacement;
    }
    return clone2;
  });
  for (const key of Object.keys(theme.colors || {})) {
    if (key === "editor.foreground" || key === "editor.background" || key.startsWith("terminal.ansi")) {
      if (!theme.colors[key]?.startsWith("#")) {
        const replacement = getReplacementColor(theme.colors[key]);
        theme.colorReplacements[replacement] = theme.colors[key];
        theme.colors[key] = replacement;
      }
    }
  }
  Object.defineProperty(theme, RESOLVED_KEY, {
    enumerable: false,
    writable: false,
    value: true
  });
  return theme;
}
async function resolveLangs(langs) {
  return Array.from(new Set((await Promise.all(
    langs.filter((l) => !isSpecialLang(l)).map(async (lang) => await normalizeGetter(lang).then((r) => Array.isArray(r) ? r : [r]))
  )).flat()));
}
async function resolveThemes(themes) {
  const resolved = await Promise.all(
    themes.map(
      async (theme) => isSpecialTheme(theme) ? null : normalizeTheme(await normalizeGetter(theme))
    )
  );
  return resolved.filter((i) => !!i);
}
let _emitDeprecation = 3;
function warnDeprecated(message, version = 3) {
  if (version > _emitDeprecation)
    return;
  {
    console.trace(`[SHIKI DEPRECATE]: ${message}`);
  }
}
let ShikiError$1 = class ShikiError2 extends Error {
  constructor(message) {
    super(message);
    this.name = "ShikiError";
  }
};
function resolveLangAlias(name, alias) {
  if (!alias)
    return name;
  if (alias[name]) {
    const resolved = /* @__PURE__ */ new Set([name]);
    while (alias[name]) {
      name = alias[name];
      if (resolved.has(name))
        throw new ShikiError$1(`Circular alias \`${Array.from(resolved).join(" -> ")} -> ${name}\``);
      resolved.add(name);
    }
  }
  return name;
}
class Registry extends Registry$1 {
  constructor(_resolver, _themes, _langs, _alias = {}) {
    super(_resolver);
    this._resolver = _resolver;
    this._themes = _themes;
    this._langs = _langs;
    this._alias = _alias;
    this._themes.map((t) => this.loadTheme(t));
    this.loadLanguages(this._langs);
  }
  _resolvedThemes = /* @__PURE__ */ new Map();
  _resolvedGrammars = /* @__PURE__ */ new Map();
  _langMap = /* @__PURE__ */ new Map();
  _langGraph = /* @__PURE__ */ new Map();
  _textmateThemeCache = /* @__PURE__ */ new WeakMap();
  _loadedThemesCache = null;
  _loadedLanguagesCache = null;
  getTheme(theme) {
    if (typeof theme === "string")
      return this._resolvedThemes.get(theme);
    else
      return this.loadTheme(theme);
  }
  loadTheme(theme) {
    const _theme = normalizeTheme(theme);
    if (_theme.name) {
      this._resolvedThemes.set(_theme.name, _theme);
      this._loadedThemesCache = null;
    }
    return _theme;
  }
  getLoadedThemes() {
    if (!this._loadedThemesCache)
      this._loadedThemesCache = [...this._resolvedThemes.keys()];
    return this._loadedThemesCache;
  }
  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`
  // is expensive. Themes can switch often especially for dual-theme support.
  //
  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,
  // we omit here so it's easier to cache the themes.
  setTheme(theme) {
    let textmateTheme = this._textmateThemeCache.get(theme);
    if (!textmateTheme) {
      textmateTheme = Theme.createFromRawTheme(theme);
      this._textmateThemeCache.set(theme, textmateTheme);
    }
    this._syncRegistry.setTheme(textmateTheme);
  }
  getGrammar(name) {
    name = resolveLangAlias(name, this._alias);
    return this._resolvedGrammars.get(name);
  }
  loadLanguage(lang) {
    if (this.getGrammar(lang.name))
      return;
    const embeddedLazilyBy = new Set(
      [...this._langMap.values()].filter((i) => i.embeddedLangsLazy?.includes(lang.name))
    );
    this._resolver.addLanguage(lang);
    const grammarConfig = {
      balancedBracketSelectors: lang.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: lang.unbalancedBracketSelectors || []
    };
    this._syncRegistry._rawGrammars.set(lang.scopeName, lang);
    const g = this.loadGrammarWithConfiguration(lang.scopeName, 1, grammarConfig);
    g.name = lang.name;
    this._resolvedGrammars.set(lang.name, g);
    if (lang.aliases) {
      lang.aliases.forEach((alias) => {
        this._alias[alias] = lang.name;
      });
    }
    this._loadedLanguagesCache = null;
    if (embeddedLazilyBy.size) {
      for (const e of embeddedLazilyBy) {
        this._resolvedGrammars.delete(e.name);
        this._loadedLanguagesCache = null;
        this._syncRegistry?._injectionGrammars?.delete(e.scopeName);
        this._syncRegistry?._grammars?.delete(e.scopeName);
        this.loadLanguage(this._langMap.get(e.name));
      }
    }
  }
  dispose() {
    super.dispose();
    this._resolvedThemes.clear();
    this._resolvedGrammars.clear();
    this._langMap.clear();
    this._langGraph.clear();
    this._loadedThemesCache = null;
  }
  loadLanguages(langs) {
    for (const lang of langs)
      this.resolveEmbeddedLanguages(lang);
    const langsGraphArray = Array.from(this._langGraph.entries());
    const missingLangs = langsGraphArray.filter(([_, lang]) => !lang);
    if (missingLangs.length) {
      const dependents = langsGraphArray.filter(([_, lang]) => {
        if (!lang)
          return false;
        const embedded = lang.embeddedLanguages || lang.embeddedLangs;
        return embedded?.some((l) => missingLangs.map(([name]) => name).includes(l));
      }).filter((lang) => !missingLangs.includes(lang));
      throw new ShikiError$1(`Missing languages ${missingLangs.map(([name]) => `\`${name}\``).join(", ")}, required by ${dependents.map(([name]) => `\`${name}\``).join(", ")}`);
    }
    for (const [_, lang] of langsGraphArray)
      this._resolver.addLanguage(lang);
    for (const [_, lang] of langsGraphArray)
      this.loadLanguage(lang);
  }
  getLoadedLanguages() {
    if (!this._loadedLanguagesCache) {
      this._loadedLanguagesCache = [
        .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])
      ];
    }
    return this._loadedLanguagesCache;
  }
  resolveEmbeddedLanguages(lang) {
    this._langMap.set(lang.name, lang);
    this._langGraph.set(lang.name, lang);
    const embedded = lang.embeddedLanguages ?? lang.embeddedLangs;
    if (embedded) {
      for (const embeddedLang of embedded)
        this._langGraph.set(embeddedLang, this._langMap.get(embeddedLang));
    }
  }
}
class Resolver {
  _langs = /* @__PURE__ */ new Map();
  _scopeToLang = /* @__PURE__ */ new Map();
  _injections = /* @__PURE__ */ new Map();
  _onigLib;
  constructor(engine, langs) {
    this._onigLib = {
      createOnigScanner: (patterns) => engine.createScanner(patterns),
      createOnigString: (s) => engine.createString(s)
    };
    langs.forEach((i) => this.addLanguage(i));
  }
  get onigLib() {
    return this._onigLib;
  }
  getLangRegistration(langIdOrAlias) {
    return this._langs.get(langIdOrAlias);
  }
  loadGrammar(scopeName) {
    return this._scopeToLang.get(scopeName);
  }
  addLanguage(l) {
    this._langs.set(l.name, l);
    if (l.aliases) {
      l.aliases.forEach((a) => {
        this._langs.set(a, l);
      });
    }
    this._scopeToLang.set(l.scopeName, l);
    if (l.injectTo) {
      l.injectTo.forEach((i) => {
        if (!this._injections.get(i))
          this._injections.set(i, []);
        this._injections.get(i).push(l.scopeName);
      });
    }
  }
  getInjections(scopeName) {
    const scopeParts = scopeName.split(".");
    let injections = [];
    for (let i = 1; i <= scopeParts.length; i++) {
      const subScopeName = scopeParts.slice(0, i).join(".");
      injections = [...injections, ...this._injections.get(subScopeName) || []];
    }
    return injections;
  }
}
let instancesCount = 0;
function createShikiInternalSync(options) {
  instancesCount += 1;
  if (options.warnings !== false && instancesCount >= 10 && instancesCount % 10 === 0)
    console.warn(`[Shiki] ${instancesCount} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
  let isDisposed = false;
  if (!options.engine)
    throw new ShikiError$1("`engine` option is required for synchronous mode");
  const langs = (options.langs || []).flat(1);
  const themes = (options.themes || []).flat(1).map(normalizeTheme);
  const resolver = new Resolver(options.engine, langs);
  const _registry = new Registry(resolver, themes, langs, options.langAlias);
  let _lastTheme;
  function resolveLangAlias$1(name) {
    return resolveLangAlias(name, options.langAlias);
  }
  function getLanguage(name) {
    ensureNotDisposed();
    const _lang = _registry.getGrammar(typeof name === "string" ? name : name.name);
    if (!_lang)
      throw new ShikiError$1(`Language \`${name}\` not found, you may need to load it first`);
    return _lang;
  }
  function getTheme(name) {
    if (name === "none")
      return { bg: "", fg: "", name: "none", settings: [], type: "dark" };
    ensureNotDisposed();
    const _theme = _registry.getTheme(name);
    if (!_theme)
      throw new ShikiError$1(`Theme \`${name}\` not found, you may need to load it first`);
    return _theme;
  }
  function setTheme(name) {
    ensureNotDisposed();
    const theme = getTheme(name);
    if (_lastTheme !== name) {
      _registry.setTheme(theme);
      _lastTheme = name;
    }
    const colorMap = _registry.getColorMap();
    return {
      theme,
      colorMap
    };
  }
  function getLoadedThemes() {
    ensureNotDisposed();
    return _registry.getLoadedThemes();
  }
  function getLoadedLanguages() {
    ensureNotDisposed();
    return _registry.getLoadedLanguages();
  }
  function loadLanguageSync(...langs2) {
    ensureNotDisposed();
    _registry.loadLanguages(langs2.flat(1));
  }
  async function loadLanguage(...langs2) {
    return loadLanguageSync(await resolveLangs(langs2));
  }
  function loadThemeSync(...themes2) {
    ensureNotDisposed();
    for (const theme of themes2.flat(1)) {
      _registry.loadTheme(theme);
    }
  }
  async function loadTheme(...themes2) {
    ensureNotDisposed();
    return loadThemeSync(await resolveThemes(themes2));
  }
  function ensureNotDisposed() {
    if (isDisposed)
      throw new ShikiError$1("Shiki instance has been disposed");
  }
  function dispose() {
    if (isDisposed)
      return;
    isDisposed = true;
    _registry.dispose();
    instancesCount -= 1;
  }
  return {
    setTheme,
    getTheme,
    getLanguage,
    getLoadedThemes,
    getLoadedLanguages,
    resolveLangAlias: resolveLangAlias$1,
    loadLanguage,
    loadLanguageSync,
    loadTheme,
    loadThemeSync,
    dispose,
    [Symbol.dispose]: dispose
  };
}
async function createShikiInternal(options) {
  if (!options.engine) {
    warnDeprecated("`engine` option is required. Use `createOnigurumaEngine` or `createJavaScriptRegexEngine` to create an engine.");
  }
  const [
    themes,
    langs,
    engine
  ] = await Promise.all([
    resolveThemes(options.themes || []),
    resolveLangs(options.langs || []),
    options.engine
  ]);
  return createShikiInternalSync({
    ...options,
    themes,
    langs,
    engine
  });
}
async function createHighlighterCore(options) {
  const internal = await createShikiInternal(options);
  return {
    getLastGrammarState: (...args) => getLastGrammarState(internal, ...args),
    codeToTokensBase: (code, options2) => codeToTokensBase(internal, code, options2),
    codeToTokensWithThemes: (code, options2) => codeToTokensWithThemes(internal, code, options2),
    codeToTokens: (code, options2) => codeToTokens(internal, code, options2),
    codeToHast: (code, options2) => codeToHast(internal, code, options2),
    codeToHtml: (code, options2) => codeToHtml(internal, code, options2),
    getBundledLanguages: () => ({}),
    getBundledThemes: () => ({}),
    ...internal,
    getInternalContext: () => internal
  };
}
function createBundledHighlighter(options) {
  const bundledLanguages2 = options.langs;
  const bundledThemes2 = options.themes;
  const engine = options.engine;
  async function createHighlighter2(options2) {
    function resolveLang(lang) {
      if (typeof lang === "string") {
        lang = options2.langAlias?.[lang] || lang;
        if (isSpecialLang(lang))
          return [];
        const bundle = bundledLanguages2[lang];
        if (!bundle)
          throw new ShikiError$2(`Language \`${lang}\` is not included in this bundle. You may want to load it from external source.`);
        return bundle;
      }
      return lang;
    }
    function resolveTheme(theme) {
      if (isSpecialTheme(theme))
        return "none";
      if (typeof theme === "string") {
        const bundle = bundledThemes2[theme];
        if (!bundle)
          throw new ShikiError$2(`Theme \`${theme}\` is not included in this bundle. You may want to load it from external source.`);
        return bundle;
      }
      return theme;
    }
    const _themes = (options2.themes ?? []).map((i) => resolveTheme(i));
    const langs = (options2.langs ?? []).map((i) => resolveLang(i));
    const core = await createHighlighterCore({
      engine: options2.engine ?? engine(),
      ...options2,
      themes: _themes,
      langs
    });
    return {
      ...core,
      loadLanguage(...langs2) {
        return core.loadLanguage(...langs2.map(resolveLang));
      },
      loadTheme(...themes) {
        return core.loadTheme(...themes.map(resolveTheme));
      },
      getBundledLanguages() {
        return bundledLanguages2;
      },
      getBundledThemes() {
        return bundledThemes2;
      }
    };
  }
  return createHighlighter2;
}
const bundledLanguagesInfo = [
  {
    "id": "abap",
    "name": "ABAP",
    "import": (() => __vitePreload(() => import("./abap-B7h4dtBh.js"), true ? [] : void 0))
  },
  {
    "id": "actionscript-3",
    "name": "ActionScript",
    "import": (() => __vitePreload(() => import("./actionscript-3-DtnkuHN2.js"), true ? [] : void 0))
  },
  {
    "id": "ada",
    "name": "Ada",
    "import": (() => __vitePreload(() => import("./ada-BZS802Se.js"), true ? [] : void 0))
  },
  {
    "id": "angular-html",
    "name": "Angular HTML",
    "import": (() => __vitePreload(() => import("./angular-html-BYG42TJr.js").then((n) => n.f), true ? __vite__mapDeps([0,1,2,3]) : void 0))
  },
  {
    "id": "angular-ts",
    "name": "Angular TypeScript",
    "import": (() => __vitePreload(() => import("./angular-ts-BftcHvZ6.js"), true ? __vite__mapDeps([4,0,1,2,3,5]) : void 0))
  },
  {
    "id": "apache",
    "name": "Apache Conf",
    "import": (() => __vitePreload(() => import("./apache-D4roVlsU.js"), true ? [] : void 0))
  },
  {
    "id": "apex",
    "name": "Apex",
    "import": (() => __vitePreload(() => import("./apex-B-mI3Md2.js"), true ? [] : void 0))
  },
  {
    "id": "apl",
    "name": "APL",
    "import": (() => __vitePreload(() => import("./apl-CGZawg-A.js"), true ? __vite__mapDeps([6,1,2,3,7,8,9]) : void 0))
  },
  {
    "id": "applescript",
    "name": "AppleScript",
    "import": (() => __vitePreload(() => import("./applescript-C43Knf0G.js"), true ? [] : void 0))
  },
  {
    "id": "ara",
    "name": "Ara",
    "import": (() => __vitePreload(() => import("./ara-DRBH84ND.js"), true ? [] : void 0))
  },
  {
    "id": "asciidoc",
    "name": "AsciiDoc",
    "aliases": [
      "adoc"
    ],
    "import": (() => __vitePreload(() => import("./asciidoc-DAaa-hb3.js"), true ? [] : void 0))
  },
  {
    "id": "asm",
    "name": "Assembly",
    "import": (() => __vitePreload(() => import("./asm-3tg4MVib.js"), true ? [] : void 0))
  },
  {
    "id": "astro",
    "name": "Astro",
    "import": (() => __vitePreload(() => import("./astro-BxdWOZvM.js"), true ? __vite__mapDeps([10,9,2,11,3,12,13]) : void 0))
  },
  {
    "id": "awk",
    "name": "AWK",
    "import": (() => __vitePreload(() => import("./awk-ChreaG-G.js"), true ? [] : void 0))
  },
  {
    "id": "ballerina",
    "name": "Ballerina",
    "import": (() => __vitePreload(() => import("./ballerina-B0yt0TYU.js"), true ? [] : void 0))
  },
  {
    "id": "bat",
    "name": "Batch File",
    "aliases": [
      "batch"
    ],
    "import": (() => __vitePreload(() => import("./bat-BzNgQIA7.js"), true ? [] : void 0))
  },
  {
    "id": "beancount",
    "name": "Beancount",
    "import": (() => __vitePreload(() => import("./beancount-aZWrE5WV.js"), true ? [] : void 0))
  },
  {
    "id": "berry",
    "name": "Berry",
    "aliases": [
      "be"
    ],
    "import": (() => __vitePreload(() => import("./berry--Qc8OslH.js"), true ? [] : void 0))
  },
  {
    "id": "bibtex",
    "name": "BibTeX",
    "import": (() => __vitePreload(() => import("./bibtex-BLeFwAes.js"), true ? [] : void 0))
  },
  {
    "id": "bicep",
    "name": "Bicep",
    "import": (() => __vitePreload(() => import("./bicep-DbBeGdXQ.js"), true ? [] : void 0))
  },
  {
    "id": "blade",
    "name": "Blade",
    "import": (() => __vitePreload(() => import("./blade-BbH7YAUi.js"), true ? __vite__mapDeps([14,15,1,2,3,7,8,16,9]) : void 0))
  },
  {
    "id": "bsl",
    "name": "1C (Enterprise)",
    "aliases": [
      "1c"
    ],
    "import": (() => __vitePreload(() => import("./bsl-DwPS0BId.js"), true ? __vite__mapDeps([17,18]) : void 0))
  },
  {
    "id": "c",
    "name": "C",
    "import": (() => __vitePreload(() => import("./c-C4VtT7JA.js"), true ? [] : void 0))
  },
  {
    "id": "c3",
    "name": "C3",
    "import": (() => __vitePreload(() => import("./c3-DCyiGUuO.js"), true ? [] : void 0))
  },
  {
    "id": "cadence",
    "name": "Cadence",
    "aliases": [
      "cdc"
    ],
    "import": (() => __vitePreload(() => import("./cadence-S_NtR5Dy.js"), true ? [] : void 0))
  },
  {
    "id": "cairo",
    "name": "Cairo",
    "import": (() => __vitePreload(() => import("./cairo-BtYx2aM5.js"), true ? __vite__mapDeps([19,20]) : void 0))
  },
  {
    "id": "clarity",
    "name": "Clarity",
    "import": (() => __vitePreload(() => import("./clarity-D2ViJC0i.js"), true ? [] : void 0))
  },
  {
    "id": "clojure",
    "name": "Clojure",
    "aliases": [
      "clj"
    ],
    "import": (() => __vitePreload(() => import("./clojure-C_G4_w5x.js"), true ? [] : void 0))
  },
  {
    "id": "cmake",
    "name": "CMake",
    "import": (() => __vitePreload(() => import("./cmake-CDfQILeU.js"), true ? [] : void 0))
  },
  {
    "id": "cobol",
    "name": "COBOL",
    "import": (() => __vitePreload(() => import("./cobol-B8r1pfPr.js"), true ? __vite__mapDeps([21,1,2,3,8]) : void 0))
  },
  {
    "id": "codeowners",
    "name": "CODEOWNERS",
    "import": (() => __vitePreload(() => import("./codeowners-awy7PWCD.js"), true ? [] : void 0))
  },
  {
    "id": "codeql",
    "name": "CodeQL",
    "aliases": [
      "ql"
    ],
    "import": (() => __vitePreload(() => import("./codeql-lfK8ppuq.js"), true ? [] : void 0))
  },
  {
    "id": "coffee",
    "name": "CoffeeScript",
    "aliases": [
      "coffeescript"
    ],
    "import": (() => __vitePreload(() => import("./coffee-XLjtuEYs.js"), true ? __vite__mapDeps([22,2]) : void 0))
  },
  {
    "id": "common-lisp",
    "name": "Common Lisp",
    "aliases": [
      "lisp"
    ],
    "import": (() => __vitePreload(() => import("./common-lisp-DAq1kaby.js"), true ? [] : void 0))
  },
  {
    "id": "coq",
    "name": "Coq",
    "import": (() => __vitePreload(() => import("./coq-l_JvzFJl.js"), true ? [] : void 0))
  },
  {
    "id": "cpp",
    "name": "C++",
    "aliases": [
      "c++"
    ],
    "import": (() => __vitePreload(() => import("./cpp-zh2ePAE_.js"), true ? __vite__mapDeps([23,24,25,26,16]) : void 0))
  },
  {
    "id": "crystal",
    "name": "Crystal",
    "import": (() => __vitePreload(() => import("./crystal-BqBRy7Ec.js"), true ? __vite__mapDeps([27,1,2,3,16,26,28]) : void 0))
  },
  {
    "id": "csharp",
    "name": "C#",
    "aliases": [
      "c#",
      "cs"
    ],
    "import": (() => __vitePreload(() => import("./csharp-DxX_6tHh.js"), true ? [] : void 0))
  },
  {
    "id": "css",
    "name": "CSS",
    "import": (() => __vitePreload(() => import("./css-BtVcDqlU.js"), true ? [] : void 0))
  },
  {
    "id": "csv",
    "name": "CSV",
    "import": (() => __vitePreload(() => import("./csv-Ba84L8e5.js"), true ? [] : void 0))
  },
  {
    "id": "cue",
    "name": "CUE",
    "import": (() => __vitePreload(() => import("./cue-BFSVLV6N.js"), true ? [] : void 0))
  },
  {
    "id": "cypher",
    "name": "Cypher",
    "aliases": [
      "cql"
    ],
    "import": (() => __vitePreload(() => import("./cypher-DbUmWIxC.js"), true ? [] : void 0))
  },
  {
    "id": "d",
    "name": "D",
    "import": (() => __vitePreload(() => import("./d-9qSZPw74.js"), true ? [] : void 0))
  },
  {
    "id": "dart",
    "name": "Dart",
    "import": (() => __vitePreload(() => import("./dart-CCSsOg9l.js"), true ? [] : void 0))
  },
  {
    "id": "dax",
    "name": "DAX",
    "import": (() => __vitePreload(() => import("./dax-CvsmLV-B.js"), true ? [] : void 0))
  },
  {
    "id": "desktop",
    "name": "Desktop",
    "import": (() => __vitePreload(() => import("./desktop-_xiGZ9X1.js"), true ? [] : void 0))
  },
  {
    "id": "diff",
    "name": "Diff",
    "import": (() => __vitePreload(() => import("./diff-BEdzuHlE.js"), true ? [] : void 0))
  },
  {
    "id": "docker",
    "name": "Dockerfile",
    "aliases": [
      "dockerfile"
    ],
    "import": (() => __vitePreload(() => import("./docker-CUaLOm2I.js"), true ? [] : void 0))
  },
  {
    "id": "dotenv",
    "name": "dotEnv",
    "import": (() => __vitePreload(() => import("./dotenv-Bb4iNxXK.js"), true ? [] : void 0))
  },
  {
    "id": "dream-maker",
    "name": "Dream Maker",
    "import": (() => __vitePreload(() => import("./dream-maker-CNLQpoF-.js"), true ? [] : void 0))
  },
  {
    "id": "edge",
    "name": "Edge",
    "import": (() => __vitePreload(() => import("./edge-CnHxQ_FD.js"), true ? __vite__mapDeps([29,11,1,2,3,15]) : void 0))
  },
  {
    "id": "elixir",
    "name": "Elixir",
    "import": (() => __vitePreload(() => import("./elixir-B_LIBv5J.js"), true ? __vite__mapDeps([30,1,2,3]) : void 0))
  },
  {
    "id": "elm",
    "name": "Elm",
    "import": (() => __vitePreload(() => import("./elm-BlO7pcFp.js"), true ? __vite__mapDeps([31,25,26]) : void 0))
  },
  {
    "id": "emacs-lisp",
    "name": "Emacs Lisp",
    "aliases": [
      "elisp"
    ],
    "import": (() => __vitePreload(() => import("./emacs-lisp-4gdXY_g3.js"), true ? [] : void 0))
  },
  {
    "id": "erb",
    "name": "ERB",
    "import": (() => __vitePreload(() => import("./erb-D0-JOe_j.js"), true ? __vite__mapDeps([32,1,2,3,33,34,7,8,16,35,11,36,13,23,24,25,26,28,37,38]) : void 0))
  },
  {
    "id": "erlang",
    "name": "Erlang",
    "aliases": [
      "erl"
    ],
    "import": (() => __vitePreload(() => import("./erlang-Ch5kuXHm.js"), true ? __vite__mapDeps([39,40]) : void 0))
  },
  {
    "id": "fennel",
    "name": "Fennel",
    "import": (() => __vitePreload(() => import("./fennel-BTELNkeT.js"), true ? [] : void 0))
  },
  {
    "id": "fish",
    "name": "Fish",
    "import": (() => __vitePreload(() => import("./fish-kGF2-4SL.js"), true ? [] : void 0))
  },
  {
    "id": "fluent",
    "name": "Fluent",
    "aliases": [
      "ftl"
    ],
    "import": (() => __vitePreload(() => import("./fluent-YyC28MRr.js"), true ? [] : void 0))
  },
  {
    "id": "fortran-fixed-form",
    "name": "Fortran (Fixed Form)",
    "aliases": [
      "f",
      "for",
      "f77"
    ],
    "import": (() => __vitePreload(() => import("./fortran-fixed-form-CpmOyvS5.js"), true ? __vite__mapDeps([41,42]) : void 0))
  },
  {
    "id": "fortran-free-form",
    "name": "Fortran (Free Form)",
    "aliases": [
      "f90",
      "f95",
      "f03",
      "f08",
      "f18"
    ],
    "import": (() => __vitePreload(() => import("./fortran-free-form-5X94ETMi.js"), true ? [] : void 0))
  },
  {
    "id": "fsharp",
    "name": "F#",
    "aliases": [
      "f#",
      "fs"
    ],
    "import": (() => __vitePreload(() => import("./fsharp-5vtGqRR9.js"), true ? __vite__mapDeps([43,40]) : void 0))
  },
  {
    "id": "gdresource",
    "name": "GDResource",
    "aliases": [
      "tscn",
      "tres"
    ],
    "import": (() => __vitePreload(() => import("./gdresource-B5TLWiFO.js"), true ? __vite__mapDeps([44,45,46]) : void 0))
  },
  {
    "id": "gdscript",
    "name": "GDScript",
    "aliases": [
      "gd"
    ],
    "import": (() => __vitePreload(() => import("./gdscript-CNW3Aj-d.js"), true ? [] : void 0))
  },
  {
    "id": "gdshader",
    "name": "GDShader",
    "import": (() => __vitePreload(() => import("./gdshader-BEzE4j_3.js"), true ? [] : void 0))
  },
  {
    "id": "genie",
    "name": "Genie",
    "import": (() => __vitePreload(() => import("./genie-BvhtM5Ga.js"), true ? [] : void 0))
  },
  {
    "id": "gherkin",
    "name": "Gherkin",
    "import": (() => __vitePreload(() => import("./gherkin-xCNF9gh8.js"), true ? [] : void 0))
  },
  {
    "id": "git-commit",
    "name": "Git Commit Message",
    "import": (() => __vitePreload(() => import("./git-commit-PP9xCApN.js"), true ? __vite__mapDeps([47,48]) : void 0))
  },
  {
    "id": "git-rebase",
    "name": "Git Rebase Message",
    "import": (() => __vitePreload(() => import("./git-rebase-D-XQSvDj.js"), true ? __vite__mapDeps([49,28]) : void 0))
  },
  {
    "id": "gleam",
    "name": "Gleam",
    "import": (() => __vitePreload(() => import("./gleam-LmNxrMsN.js"), true ? [] : void 0))
  },
  {
    "id": "glimmer-js",
    "name": "Glimmer JS",
    "aliases": [
      "gjs"
    ],
    "import": (() => __vitePreload(() => import("./glimmer-js-h2QNNiD7.js"), true ? __vite__mapDeps([50,2,11,3,1]) : void 0))
  },
  {
    "id": "glimmer-ts",
    "name": "Glimmer TS",
    "aliases": [
      "gts"
    ],
    "import": (() => __vitePreload(() => import("./glimmer-ts-Bk3uX6Ae.js"), true ? __vite__mapDeps([51,11,3,2,1]) : void 0))
  },
  {
    "id": "glsl",
    "name": "GLSL",
    "import": (() => __vitePreload(() => import("./glsl-CGsiYPcu.js"), true ? __vite__mapDeps([25,26]) : void 0))
  },
  {
    "id": "gn",
    "name": "GN",
    "import": (() => __vitePreload(() => import("./gn-OUMx7fqt.js"), true ? [] : void 0))
  },
  {
    "id": "gnuplot",
    "name": "Gnuplot",
    "import": (() => __vitePreload(() => import("./gnuplot-tV8vezdE.js"), true ? [] : void 0))
  },
  {
    "id": "go",
    "name": "Go",
    "import": (() => __vitePreload(() => import("./go-DRMr3iML.js"), true ? [] : void 0))
  },
  {
    "id": "graphql",
    "name": "GraphQL",
    "aliases": [
      "gql"
    ],
    "import": (() => __vitePreload(() => import("./graphql-CwmtR1ib.js"), true ? __vite__mapDeps([35,2,11,36,13]) : void 0))
  },
  {
    "id": "groovy",
    "name": "Groovy",
    "import": (() => __vitePreload(() => import("./groovy-Bn4MhXgW.js"), true ? [] : void 0))
  },
  {
    "id": "hack",
    "name": "Hack",
    "import": (() => __vitePreload(() => import("./hack-BTX3ICIE.js"), true ? __vite__mapDeps([52,1,2,3,16]) : void 0))
  },
  {
    "id": "haml",
    "name": "Ruby Haml",
    "import": (() => __vitePreload(() => import("./haml-DrIklt7F.js"), true ? __vite__mapDeps([34,2,3]) : void 0))
  },
  {
    "id": "handlebars",
    "name": "Handlebars",
    "aliases": [
      "hbs"
    ],
    "import": (() => __vitePreload(() => import("./handlebars-yWFGGD2R.js"), true ? __vite__mapDeps([53,1,2,3,38]) : void 0))
  },
  {
    "id": "haskell",
    "name": "Haskell",
    "aliases": [
      "hs"
    ],
    "import": (() => __vitePreload(() => import("./haskell-CzPS7wjM.js"), true ? [] : void 0))
  },
  {
    "id": "haxe",
    "name": "Haxe",
    "import": (() => __vitePreload(() => import("./haxe-BpobLYM9.js"), true ? [] : void 0))
  },
  {
    "id": "hcl",
    "name": "HashiCorp HCL",
    "import": (() => __vitePreload(() => import("./hcl-axoq0Ycu.js"), true ? [] : void 0))
  },
  {
    "id": "hjson",
    "name": "Hjson",
    "import": (() => __vitePreload(() => import("./hjson-I7LcauIB.js"), true ? [] : void 0))
  },
  {
    "id": "hlsl",
    "name": "HLSL",
    "import": (() => __vitePreload(() => import("./hlsl-TRzjajlb.js"), true ? [] : void 0))
  },
  {
    "id": "html",
    "name": "HTML",
    "import": (() => __vitePreload(() => import("./html-GC16tDh9.js"), true ? __vite__mapDeps([1,2,3]) : void 0))
  },
  {
    "id": "html-derivative",
    "name": "HTML (Derivative)",
    "import": (() => __vitePreload(() => import("./html-derivative-HU9p64q4.js"), true ? __vite__mapDeps([15,1,2,3]) : void 0))
  },
  {
    "id": "http",
    "name": "HTTP",
    "import": (() => __vitePreload(() => import("./http-DjsOm9E4.js"), true ? __vite__mapDeps([54,28,9,7,8,35,2,11,36,13]) : void 0))
  },
  {
    "id": "hurl",
    "name": "Hurl",
    "import": (() => __vitePreload(() => import("./hurl-Am2cDU4f.js"), true ? __vite__mapDeps([55,35,2,11,36,13,7,8,56]) : void 0))
  },
  {
    "id": "hxml",
    "name": "HXML",
    "import": (() => __vitePreload(() => import("./hxml-Jle7oGdm.js"), true ? __vite__mapDeps([57,58]) : void 0))
  },
  {
    "id": "hy",
    "name": "Hy",
    "import": (() => __vitePreload(() => import("./hy-B1k9U6S8.js"), true ? [] : void 0))
  },
  {
    "id": "imba",
    "name": "Imba",
    "import": (() => __vitePreload(() => import("./imba-C4923lSV.js"), true ? [] : void 0))
  },
  {
    "id": "ini",
    "name": "INI",
    "aliases": [
      "properties"
    ],
    "import": (() => __vitePreload(() => import("./ini-B84Ha1bx.js"), true ? [] : void 0))
  },
  {
    "id": "java",
    "name": "Java",
    "import": (() => __vitePreload(() => import("./java-BfXh-0uJ.js"), true ? [] : void 0))
  },
  {
    "id": "javascript",
    "name": "JavaScript",
    "aliases": [
      "js",
      "cjs",
      "mjs"
    ],
    "import": (() => __vitePreload(() => import("./javascript-BsAkV7mL.js"), true ? [] : void 0))
  },
  {
    "id": "jinja",
    "name": "Jinja",
    "import": (() => __vitePreload(() => import("./jinja-FkIlHBgj.js"), true ? __vite__mapDeps([59,1,2,3]) : void 0))
  },
  {
    "id": "jison",
    "name": "Jison",
    "import": (() => __vitePreload(() => import("./jison-BkdOIOd4.js"), true ? __vite__mapDeps([60,2]) : void 0))
  },
  {
    "id": "json",
    "name": "JSON",
    "import": (() => __vitePreload(() => import("./json-TjWBGEk1.js"), true ? [] : void 0))
  },
  {
    "id": "json5",
    "name": "JSON5",
    "import": (() => __vitePreload(() => import("./json5-DCGCKrmX.js"), true ? [] : void 0))
  },
  {
    "id": "jsonc",
    "name": "JSON with Comments",
    "import": (() => __vitePreload(() => import("./jsonc-DLVLp8id.js"), true ? [] : void 0))
  },
  {
    "id": "jsonl",
    "name": "JSON Lines",
    "import": (() => __vitePreload(() => import("./jsonl-B-R_pDGg.js"), true ? [] : void 0))
  },
  {
    "id": "jsonnet",
    "name": "Jsonnet",
    "import": (() => __vitePreload(() => import("./jsonnet-Cs8BnnC6.js"), true ? [] : void 0))
  },
  {
    "id": "jssm",
    "name": "JSSM",
    "aliases": [
      "fsl"
    ],
    "import": (() => __vitePreload(() => import("./jssm-DDuANZ2u.js"), true ? [] : void 0))
  },
  {
    "id": "jsx",
    "name": "JSX",
    "import": (() => __vitePreload(() => import("./jsx-BPmvoin2.js"), true ? [] : void 0))
  },
  {
    "id": "julia",
    "name": "Julia",
    "aliases": [
      "jl"
    ],
    "import": (() => __vitePreload(() => import("./julia-CU_UwNb8.js"), true ? __vite__mapDeps([61,23,24,25,26,16,20,2,62]) : void 0))
  },
  {
    "id": "kdl",
    "name": "KDL",
    "import": (() => __vitePreload(() => import("./kdl-DzNQTDs7.js"), true ? [] : void 0))
  },
  {
    "id": "kotlin",
    "name": "Kotlin",
    "aliases": [
      "kt",
      "kts"
    ],
    "import": (() => __vitePreload(() => import("./kotlin-BM2ZNTMh.js"), true ? [] : void 0))
  },
  {
    "id": "kusto",
    "name": "Kusto",
    "aliases": [
      "kql"
    ],
    "import": (() => __vitePreload(() => import("./kusto-dtpuxMFE.js"), true ? [] : void 0))
  },
  {
    "id": "latex",
    "name": "LaTeX",
    "import": (() => __vitePreload(() => import("./latex-BRmxFpXE.js"), true ? __vite__mapDeps([63,64,62]) : void 0))
  },
  {
    "id": "lean",
    "name": "Lean 4",
    "aliases": [
      "lean4"
    ],
    "import": (() => __vitePreload(() => import("./lean-CTow-IzD.js"), true ? [] : void 0))
  },
  {
    "id": "less",
    "name": "Less",
    "import": (() => __vitePreload(() => import("./less-BAzLMJNR.js"), true ? [] : void 0))
  },
  {
    "id": "liquid",
    "name": "Liquid",
    "import": (() => __vitePreload(() => import("./liquid-QmJ_LYTW.js"), true ? __vite__mapDeps([65,1,2,3,9]) : void 0))
  },
  {
    "id": "llvm",
    "name": "LLVM IR",
    "import": (() => __vitePreload(() => import("./llvm-Cga37tC_.js"), true ? [] : void 0))
  },
  {
    "id": "log",
    "name": "Log file",
    "import": (() => __vitePreload(() => import("./log-BF22rfM9.js"), true ? [] : void 0))
  },
  {
    "id": "logo",
    "name": "Logo",
    "import": (() => __vitePreload(() => import("./logo-D9l7oEJ8.js"), true ? [] : void 0))
  },
  {
    "id": "lua",
    "name": "Lua",
    "import": (() => __vitePreload(() => import("./lua-BVbbqwZC.js"), true ? __vite__mapDeps([37,26]) : void 0))
  },
  {
    "id": "luau",
    "name": "Luau",
    "import": (() => __vitePreload(() => import("./luau-CdZ6BoEa.js"), true ? [] : void 0))
  },
  {
    "id": "make",
    "name": "Makefile",
    "aliases": [
      "makefile"
    ],
    "import": (() => __vitePreload(() => import("./make-DLtqaK4D.js"), true ? [] : void 0))
  },
  {
    "id": "markdown",
    "name": "Markdown",
    "aliases": [
      "md"
    ],
    "import": (() => __vitePreload(() => import("./markdown-F_EULe_G.js"), true ? [] : void 0))
  },
  {
    "id": "marko",
    "name": "Marko",
    "import": (() => __vitePreload(() => import("./marko-BDLRyCCe.js"), true ? __vite__mapDeps([66,3,67,5,11]) : void 0))
  },
  {
    "id": "matlab",
    "name": "MATLAB",
    "import": (() => __vitePreload(() => import("./matlab-7XHduepk.js"), true ? [] : void 0))
  },
  {
    "id": "mdc",
    "name": "MDC",
    "import": (() => __vitePreload(() => import("./mdc-BQMA9IL9.js"), true ? __vite__mapDeps([68,40,38,15,1,2,3]) : void 0))
  },
  {
    "id": "mdx",
    "name": "MDX",
    "import": (() => __vitePreload(() => import("./mdx-D5wExp-O.js"), true ? [] : void 0))
  },
  {
    "id": "mermaid",
    "name": "Mermaid",
    "aliases": [
      "mmd"
    ],
    "import": (() => __vitePreload(() => import("./mermaid-z_1ejSlp.js"), true ? [] : void 0))
  },
  {
    "id": "mipsasm",
    "name": "MIPS Assembly",
    "aliases": [
      "mips"
    ],
    "import": (() => __vitePreload(() => import("./mipsasm-BQyyUrpa.js"), true ? [] : void 0))
  },
  {
    "id": "mojo",
    "name": "Mojo",
    "import": (() => __vitePreload(() => import("./mojo-oCdXaqgR.js"), true ? [] : void 0))
  },
  {
    "id": "moonbit",
    "name": "MoonBit",
    "aliases": [
      "mbt",
      "mbti"
    ],
    "import": (() => __vitePreload(() => import("./moonbit-BJwFbXFw.js"), true ? [] : void 0))
  },
  {
    "id": "move",
    "name": "Move",
    "import": (() => __vitePreload(() => import("./move-DhTNmxqC.js"), true ? [] : void 0))
  },
  {
    "id": "narrat",
    "name": "Narrat Language",
    "aliases": [
      "nar"
    ],
    "import": (() => __vitePreload(() => import("./narrat-CLjGcbCy.js"), true ? [] : void 0))
  },
  {
    "id": "nextflow",
    "name": "Nextflow",
    "aliases": [
      "nf"
    ],
    "import": (() => __vitePreload(() => import("./nextflow-B-RDCzl7.js"), true ? [] : void 0))
  },
  {
    "id": "nginx",
    "name": "Nginx",
    "import": (() => __vitePreload(() => import("./nginx-BFAkI5_-.js"), true ? __vite__mapDeps([69,37,26]) : void 0))
  },
  {
    "id": "nim",
    "name": "Nim",
    "import": (() => __vitePreload(() => import("./nim-B3PAIZ4D.js"), true ? __vite__mapDeps([70,26,1,2,3,7,8,25,40]) : void 0))
  },
  {
    "id": "nix",
    "name": "Nix",
    "import": (() => __vitePreload(() => import("./nix-ByWcmvXF.js"), true ? [] : void 0))
  },
  {
    "id": "nushell",
    "name": "nushell",
    "aliases": [
      "nu"
    ],
    "import": (() => __vitePreload(() => import("./nushell-CwevsFPL.js"), true ? [] : void 0))
  },
  {
    "id": "objective-c",
    "name": "Objective-C",
    "aliases": [
      "objc"
    ],
    "import": (() => __vitePreload(() => import("./objective-c-BRoNQF42.js"), true ? [] : void 0))
  },
  {
    "id": "objective-cpp",
    "name": "Objective-C++",
    "import": (() => __vitePreload(() => import("./objective-cpp-DEoN9Fe5.js"), true ? [] : void 0))
  },
  {
    "id": "ocaml",
    "name": "OCaml",
    "import": (() => __vitePreload(() => import("./ocaml-B1kfGk9Y.js"), true ? [] : void 0))
  },
  {
    "id": "odin",
    "name": "Odin",
    "import": (() => __vitePreload(() => import("./odin-CNQ56Ay2.js"), true ? [] : void 0))
  },
  {
    "id": "openscad",
    "name": "OpenSCAD",
    "aliases": [
      "scad"
    ],
    "import": (() => __vitePreload(() => import("./openscad-C_m7ehZF.js"), true ? [] : void 0))
  },
  {
    "id": "pascal",
    "name": "Pascal",
    "import": (() => __vitePreload(() => import("./pascal-CU8Kjkr_.js"), true ? [] : void 0))
  },
  {
    "id": "perl",
    "name": "Perl",
    "import": (() => __vitePreload(() => import("./perl-HITCDkgu.js"), true ? __vite__mapDeps([71,1,2,3,7,8,16]) : void 0))
  },
  {
    "id": "php",
    "name": "PHP",
    "import": (() => __vitePreload(() => import("./php-C2HieitX.js"), true ? __vite__mapDeps([72,1,2,3,7,8,16,9]) : void 0))
  },
  {
    "id": "pkl",
    "name": "Pkl",
    "import": (() => __vitePreload(() => import("./pkl-BsByaYax.js"), true ? [] : void 0))
  },
  {
    "id": "plsql",
    "name": "PL/SQL",
    "import": (() => __vitePreload(() => import("./plsql-B3Na24V4.js"), true ? [] : void 0))
  },
  {
    "id": "po",
    "name": "Gettext PO",
    "aliases": [
      "pot",
      "potx"
    ],
    "import": (() => __vitePreload(() => import("./po-BajfNjc5.js"), true ? [] : void 0))
  },
  {
    "id": "polar",
    "name": "Polar",
    "import": (() => __vitePreload(() => import("./polar-BB-dlxnO.js"), true ? [] : void 0))
  },
  {
    "id": "postcss",
    "name": "PostCSS",
    "import": (() => __vitePreload(() => import("./postcss-kj1IbjVd.js"), true ? [] : void 0))
  },
  {
    "id": "powerquery",
    "name": "PowerQuery",
    "import": (() => __vitePreload(() => import("./powerquery-B-e1fO-k.js"), true ? [] : void 0))
  },
  {
    "id": "powershell",
    "name": "PowerShell",
    "aliases": [
      "ps",
      "ps1"
    ],
    "import": (() => __vitePreload(() => import("./powershell-BcMVbGpk.js"), true ? [] : void 0))
  },
  {
    "id": "prisma",
    "name": "Prisma",
    "import": (() => __vitePreload(() => import("./prisma-bmxcSDxq.js"), true ? [] : void 0))
  },
  {
    "id": "prolog",
    "name": "Prolog",
    "import": (() => __vitePreload(() => import("./prolog-BT9GCzqD.js"), true ? [] : void 0))
  },
  {
    "id": "proto",
    "name": "Protocol Buffer 3",
    "aliases": [
      "protobuf"
    ],
    "import": (() => __vitePreload(() => import("./proto-Ds-m32NR.js"), true ? [] : void 0))
  },
  {
    "id": "pug",
    "name": "Pug",
    "aliases": [
      "jade"
    ],
    "import": (() => __vitePreload(() => import("./pug-BwQB43qN.js"), true ? __vite__mapDeps([73,2,3,1]) : void 0))
  },
  {
    "id": "puppet",
    "name": "Puppet",
    "import": (() => __vitePreload(() => import("./puppet-N15G4Usj.js"), true ? [] : void 0))
  },
  {
    "id": "purescript",
    "name": "PureScript",
    "import": (() => __vitePreload(() => import("./purescript-DrwsEYNH.js"), true ? [] : void 0))
  },
  {
    "id": "python",
    "name": "Python",
    "aliases": [
      "py"
    ],
    "import": (() => __vitePreload(() => import("./python-CrdIx4PZ.js"), true ? [] : void 0))
  },
  {
    "id": "qml",
    "name": "QML",
    "import": (() => __vitePreload(() => import("./qml-jtL8okyu.js"), true ? __vite__mapDeps([74,2]) : void 0))
  },
  {
    "id": "qmldir",
    "name": "QML Directory",
    "import": (() => __vitePreload(() => import("./qmldir-DuMSk0Oz.js"), true ? [] : void 0))
  },
  {
    "id": "qss",
    "name": "Qt Style Sheets",
    "import": (() => __vitePreload(() => import("./qss-BFrB6p4y.js"), true ? [] : void 0))
  },
  {
    "id": "r",
    "name": "R",
    "import": (() => __vitePreload(() => import("./r-Dpdc-Kyk.js"), true ? [] : void 0))
  },
  {
    "id": "racket",
    "name": "Racket",
    "import": (() => __vitePreload(() => import("./racket-DbA06HL7.js"), true ? [] : void 0))
  },
  {
    "id": "raku",
    "name": "Raku",
    "aliases": [
      "perl6"
    ],
    "import": (() => __vitePreload(() => import("./raku-6v-Y17bs.js"), true ? [] : void 0))
  },
  {
    "id": "razor",
    "name": "ASP.NET Razor",
    "import": (() => __vitePreload(() => import("./razor-gBXW6YBJ.js"), true ? __vite__mapDeps([75,1,2,3,76]) : void 0))
  },
  {
    "id": "reg",
    "name": "Windows Registry Script",
    "import": (() => __vitePreload(() => import("./reg-CULnG2WX.js"), true ? [] : void 0))
  },
  {
    "id": "regexp",
    "name": "RegExp",
    "aliases": [
      "regex"
    ],
    "import": (() => __vitePreload(() => import("./regexp-BxWeO75u.js"), true ? [] : void 0))
  },
  {
    "id": "rel",
    "name": "Rel",
    "import": (() => __vitePreload(() => import("./rel-CHRwzjd4.js"), true ? [] : void 0))
  },
  {
    "id": "riscv",
    "name": "RISC-V",
    "import": (() => __vitePreload(() => import("./riscv-BNQ9cVpw.js"), true ? [] : void 0))
  },
  {
    "id": "ron",
    "name": "RON",
    "import": (() => __vitePreload(() => import("./ron-mATCac1u.js"), true ? [] : void 0))
  },
  {
    "id": "rosmsg",
    "name": "ROS Interface",
    "import": (() => __vitePreload(() => import("./rosmsg-Bfahr6vb.js"), true ? [] : void 0))
  },
  {
    "id": "rst",
    "name": "reStructuredText",
    "import": (() => __vitePreload(() => import("./rst-CKCyRjfY.js"), true ? __vite__mapDeps([77,15,1,2,3,23,24,25,26,16,20,28,38,78,33,34,7,8,35,11,36,13,37]) : void 0))
  },
  {
    "id": "ruby",
    "name": "Ruby",
    "aliases": [
      "rb"
    ],
    "import": (() => __vitePreload(() => import("./ruby-CPCASdTw.js"), true ? __vite__mapDeps([33,1,2,3,34,7,8,16,35,11,36,13,23,24,25,26,28,37,38]) : void 0))
  },
  {
    "id": "rust",
    "name": "Rust",
    "aliases": [
      "rs"
    ],
    "import": (() => __vitePreload(() => import("./rust-CMNYZh5a.js"), true ? [] : void 0))
  },
  {
    "id": "sas",
    "name": "SAS",
    "import": (() => __vitePreload(() => import("./sas-BLBgC3TA.js"), true ? __vite__mapDeps([79,16]) : void 0))
  },
  {
    "id": "sass",
    "name": "Sass",
    "import": (() => __vitePreload(() => import("./sass-BheygBdF.js"), true ? [] : void 0))
  },
  {
    "id": "scala",
    "name": "Scala",
    "import": (() => __vitePreload(() => import("./scala-B-_7vFVn.js"), true ? [] : void 0))
  },
  {
    "id": "scheme",
    "name": "Scheme",
    "import": (() => __vitePreload(() => import("./scheme-BSHdPinv.js"), true ? [] : void 0))
  },
  {
    "id": "scss",
    "name": "SCSS",
    "import": (() => __vitePreload(() => import("./scss-Dq-LbI_c.js"), true ? __vite__mapDeps([5,3]) : void 0))
  },
  {
    "id": "sdbl",
    "name": "1C (Query)",
    "aliases": [
      "1c-query"
    ],
    "import": (() => __vitePreload(() => import("./sdbl-BBUhycGU.js"), true ? [] : void 0))
  },
  {
    "id": "shaderlab",
    "name": "ShaderLab",
    "aliases": [
      "shader"
    ],
    "import": (() => __vitePreload(() => import("./shaderlab-C07uO3dL.js"), true ? __vite__mapDeps([80,81]) : void 0))
  },
  {
    "id": "shellscript",
    "name": "Shell",
    "aliases": [
      "bash",
      "sh",
      "shell",
      "zsh"
    ],
    "import": (() => __vitePreload(() => import("./shellscript-CQ8MXh-D.js"), true ? [] : void 0))
  },
  {
    "id": "shellsession",
    "name": "Shell Session",
    "aliases": [
      "console"
    ],
    "import": (() => __vitePreload(() => import("./shellsession-CkeTp4M1.js"), true ? __vite__mapDeps([82,28]) : void 0))
  },
  {
    "id": "smalltalk",
    "name": "Smalltalk",
    "import": (() => __vitePreload(() => import("./smalltalk-qxcGy4fT.js"), true ? [] : void 0))
  },
  {
    "id": "solidity",
    "name": "Solidity",
    "import": (() => __vitePreload(() => import("./solidity-CSTQ0FCC.js"), true ? [] : void 0))
  },
  {
    "id": "soy",
    "name": "Closure Templates",
    "aliases": [
      "closure-templates"
    ],
    "import": (() => __vitePreload(() => import("./soy-BHaHgMUy.js"), true ? __vite__mapDeps([83,1,2,3]) : void 0))
  },
  {
    "id": "sparql",
    "name": "SPARQL",
    "import": (() => __vitePreload(() => import("./sparql-DswowMAp.js"), true ? __vite__mapDeps([84,85]) : void 0))
  },
  {
    "id": "splunk",
    "name": "Splunk Query Language",
    "aliases": [
      "spl"
    ],
    "import": (() => __vitePreload(() => import("./splunk-DcGJXIDa.js"), true ? [] : void 0))
  },
  {
    "id": "sql",
    "name": "SQL",
    "import": (() => __vitePreload(() => import("./sql-DzUuSofg.js"), true ? [] : void 0))
  },
  {
    "id": "ssh-config",
    "name": "SSH Config",
    "import": (() => __vitePreload(() => import("./ssh-config-Bk_I5wDR.js"), true ? [] : void 0))
  },
  {
    "id": "stata",
    "name": "Stata",
    "import": (() => __vitePreload(() => import("./stata-Dl7wDdBE.js"), true ? __vite__mapDeps([86,16]) : void 0))
  },
  {
    "id": "stylus",
    "name": "Stylus",
    "aliases": [
      "styl"
    ],
    "import": (() => __vitePreload(() => import("./stylus-DXFa_2Jl.js"), true ? [] : void 0))
  },
  {
    "id": "surrealql",
    "name": "SurrealQL",
    "aliases": [
      "surql"
    ],
    "import": (() => __vitePreload(() => import("./surrealql-Bs3vUeKA.js"), true ? __vite__mapDeps([87,2]) : void 0))
  },
  {
    "id": "svelte",
    "name": "Svelte",
    "import": (() => __vitePreload(() => import("./svelte-BAOk4slW.js"), true ? __vite__mapDeps([88,2,11,3,12]) : void 0))
  },
  {
    "id": "swift",
    "name": "Swift",
    "import": (() => __vitePreload(() => import("./swift-DnZ2euNj.js"), true ? [] : void 0))
  },
  {
    "id": "system-verilog",
    "name": "SystemVerilog",
    "import": (() => __vitePreload(() => import("./system-verilog-BcESSvRn.js"), true ? [] : void 0))
  },
  {
    "id": "systemd",
    "name": "Systemd Units",
    "import": (() => __vitePreload(() => import("./systemd-DJPFjU02.js"), true ? [] : void 0))
  },
  {
    "id": "talonscript",
    "name": "TalonScript",
    "aliases": [
      "talon"
    ],
    "import": (() => __vitePreload(() => import("./talonscript-CEEMXJTH.js"), true ? [] : void 0))
  },
  {
    "id": "tasl",
    "name": "Tasl",
    "import": (() => __vitePreload(() => import("./tasl-DfOr2qHi.js"), true ? [] : void 0))
  },
  {
    "id": "tcl",
    "name": "Tcl",
    "import": (() => __vitePreload(() => import("./tcl-CTsc4-t7.js"), true ? [] : void 0))
  },
  {
    "id": "templ",
    "name": "Templ",
    "import": (() => __vitePreload(() => import("./templ-CSEiQwNm.js"), true ? __vite__mapDeps([89,90,2,3]) : void 0))
  },
  {
    "id": "terraform",
    "name": "Terraform",
    "aliases": [
      "tf",
      "tfvars"
    ],
    "import": (() => __vitePreload(() => import("./terraform-CeztUfUr.js"), true ? [] : void 0))
  },
  {
    "id": "tex",
    "name": "TeX",
    "import": (() => __vitePreload(() => import("./tex-CcHKQ11y.js"), true ? __vite__mapDeps([64,62]) : void 0))
  },
  {
    "id": "toml",
    "name": "TOML",
    "import": (() => __vitePreload(() => import("./toml-vHPzWDj6.js"), true ? [] : void 0))
  },
  {
    "id": "ts-tags",
    "name": "TypeScript with Tags",
    "aliases": [
      "lit"
    ],
    "import": (() => __vitePreload(() => import("./ts-tags-cG2hZuda.js"), true ? __vite__mapDeps([91,11,3,2,25,26,1,16,7,8]) : void 0))
  },
  {
    "id": "tsv",
    "name": "TSV",
    "import": (() => __vitePreload(() => import("./tsv-ChRVFvMy.js"), true ? [] : void 0))
  },
  {
    "id": "tsx",
    "name": "TSX",
    "import": (() => __vitePreload(() => import("./tsx-CmGGo4Hm.js"), true ? [] : void 0))
  },
  {
    "id": "turtle",
    "name": "Turtle",
    "import": (() => __vitePreload(() => import("./turtle-BnC7StHY.js"), true ? [] : void 0))
  },
  {
    "id": "twig",
    "name": "Twig",
    "import": (() => __vitePreload(() => import("./twig-CDYLbMhD.js"), true ? __vite__mapDeps([92,3,2,5,72,1,7,8,16,9,20,33,34,35,11,36,13,23,24,25,26,28,37,38]) : void 0))
  },
  {
    "id": "typescript",
    "name": "TypeScript",
    "aliases": [
      "ts",
      "cts",
      "mts"
    ],
    "import": (() => __vitePreload(() => import("./typescript-CP6ECzON.js"), true ? [] : void 0))
  },
  {
    "id": "typespec",
    "name": "TypeSpec",
    "aliases": [
      "tsp"
    ],
    "import": (() => __vitePreload(() => import("./typespec-CkDVVIcK.js"), true ? [] : void 0))
  },
  {
    "id": "typst",
    "name": "Typst",
    "aliases": [
      "typ"
    ],
    "import": (() => __vitePreload(() => import("./typst-XYLFxYau.js"), true ? [] : void 0))
  },
  {
    "id": "v",
    "name": "V",
    "import": (() => __vitePreload(() => import("./v-BSYXvR4g.js"), true ? [] : void 0))
  },
  {
    "id": "vala",
    "name": "Vala",
    "import": (() => __vitePreload(() => import("./vala-qJa5rry9.js"), true ? [] : void 0))
  },
  {
    "id": "vb",
    "name": "Visual Basic",
    "aliases": [
      "cmd"
    ],
    "import": (() => __vitePreload(() => import("./vb-Bzg9rspf.js"), true ? [] : void 0))
  },
  {
    "id": "verilog",
    "name": "Verilog",
    "import": (() => __vitePreload(() => import("./verilog-CCb_iTfF.js"), true ? [] : void 0))
  },
  {
    "id": "vhdl",
    "name": "VHDL",
    "import": (() => __vitePreload(() => import("./vhdl-DMqk4T2s.js"), true ? [] : void 0))
  },
  {
    "id": "viml",
    "name": "Vim Script",
    "aliases": [
      "vim",
      "vimscript"
    ],
    "import": (() => __vitePreload(() => import("./viml--FINbfoq.js"), true ? [] : void 0))
  },
  {
    "id": "vue",
    "name": "Vue",
    "import": (() => __vitePreload(() => import("./vue-K-7Ga-y8.js"), true ? __vite__mapDeps([93,3,2,11,9,1,15]) : void 0))
  },
  {
    "id": "vue-html",
    "name": "Vue HTML",
    "import": (() => __vitePreload(() => import("./vue-html-DhreShjd.js"), true ? __vite__mapDeps([94,2]) : void 0))
  },
  {
    "id": "vue-vine",
    "name": "Vue Vine",
    "import": (() => __vitePreload(() => import("./vue-vine-rMIwOpFf.js"), true ? __vite__mapDeps([95,3,5,67,96,12,2]) : void 0))
  },
  {
    "id": "vyper",
    "name": "Vyper",
    "aliases": [
      "vy"
    ],
    "import": (() => __vitePreload(() => import("./vyper-DP4whl13.js"), true ? [] : void 0))
  },
  {
    "id": "wasm",
    "name": "WebAssembly",
    "import": (() => __vitePreload(() => import("./wasm-BBh6f151.js"), true ? [] : void 0))
  },
  {
    "id": "wenyan",
    "name": "Wenyan",
    "aliases": [
      ""
    ],
    "import": (() => __vitePreload(() => import("./wenyan-BdqozpMZ.js"), true ? [] : void 0))
  },
  {
    "id": "wgsl",
    "name": "WGSL",
    "import": (() => __vitePreload(() => import("./wgsl-Vo-hHVWH.js"), true ? [] : void 0))
  },
  {
    "id": "wikitext",
    "name": "Wikitext",
    "aliases": [
      "mediawiki",
      "wiki"
    ],
    "import": (() => __vitePreload(() => import("./wikitext-BDjE6pmL.js"), true ? [] : void 0))
  },
  {
    "id": "wit",
    "name": "WebAssembly Interface Types",
    "import": (() => __vitePreload(() => import("./wit-C_nQzOkY.js"), true ? [] : void 0))
  },
  {
    "id": "wolfram",
    "name": "Wolfram",
    "aliases": [
      "wl"
    ],
    "import": (() => __vitePreload(() => import("./wolfram-CRmjUoI4.js"), true ? [] : void 0))
  },
  {
    "id": "xml",
    "name": "XML",
    "import": (() => __vitePreload(() => import("./xml-BMzZeaqs.js"), true ? __vite__mapDeps([7,8]) : void 0))
  },
  {
    "id": "xsl",
    "name": "XSL",
    "import": (() => __vitePreload(() => import("./xsl-CnwVr_6q.js"), true ? __vite__mapDeps([97,7,8]) : void 0))
  },
  {
    "id": "yaml",
    "name": "YAML",
    "aliases": [
      "yml"
    ],
    "import": (() => __vitePreload(() => import("./yaml-B_vW5iTY.js"), true ? [] : void 0))
  },
  {
    "id": "zenscript",
    "name": "ZenScript",
    "import": (() => __vitePreload(() => import("./zenscript-DFINJL6j.js"), true ? [] : void 0))
  },
  {
    "id": "zig",
    "name": "Zig",
    "import": (() => __vitePreload(() => import("./zig-CS4FMAZp.js"), true ? [] : void 0))
  }
];
const bundledLanguagesBase = Object.fromEntries(bundledLanguagesInfo.map((i) => [i.id, i.import]));
const bundledLanguagesAlias = Object.fromEntries(bundledLanguagesInfo.flatMap((i) => i.aliases?.map((a) => [a, i.import]) || []));
const bundledLanguages = {
  ...bundledLanguagesBase,
  ...bundledLanguagesAlias
};
const bundledThemesInfo = [
  {
    "id": "andromeeda",
    "displayName": "Andromeeda",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./andromeeda-C847lm7Z.js"), true ? [] : void 0))
  },
  {
    "id": "aurora-x",
    "displayName": "Aurora X",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./aurora-x-wJ4-eM2h.js"), true ? [] : void 0))
  },
  {
    "id": "ayu-dark",
    "displayName": "Ayu Dark",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./ayu-dark-CzSi5Etu.js"), true ? [] : void 0))
  },
  {
    "id": "ayu-light",
    "displayName": "Ayu Light",
    "type": "light",
    "import": (() => __vitePreload(() => import("./ayu-light-C_O7IUhi.js"), true ? [] : void 0))
  },
  {
    "id": "ayu-mirage",
    "displayName": "Ayu Mirage",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./ayu-mirage-CCitYj6x.js"), true ? [] : void 0))
  },
  {
    "id": "catppuccin-frappe",
    "displayName": "Catppuccin Frapp",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./catppuccin-frappe-C21OPQfC.js"), true ? [] : void 0))
  },
  {
    "id": "catppuccin-latte",
    "displayName": "Catppuccin Latte",
    "type": "light",
    "import": (() => __vitePreload(() => import("./catppuccin-latte-0ZtXlsrX.js"), true ? [] : void 0))
  },
  {
    "id": "catppuccin-macchiato",
    "displayName": "Catppuccin Macchiato",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./catppuccin-macchiato-BD_FR4sl.js"), true ? [] : void 0))
  },
  {
    "id": "catppuccin-mocha",
    "displayName": "Catppuccin Mocha",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./catppuccin-mocha-C653csR5.js"), true ? [] : void 0))
  },
  {
    "id": "dark-plus",
    "displayName": "Dark Plus",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./dark-plus-DmZ1Dzd4.js"), true ? [] : void 0))
  },
  {
    "id": "dracula",
    "displayName": "Dracula Theme",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./dracula-B8-AVrwI.js"), true ? [] : void 0))
  },
  {
    "id": "dracula-soft",
    "displayName": "Dracula Theme Soft",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./dracula-soft-BHeefow7.js"), true ? [] : void 0))
  },
  {
    "id": "everforest-dark",
    "displayName": "Everforest Dark",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./everforest-dark-Cg1xdODP.js"), true ? [] : void 0))
  },
  {
    "id": "everforest-light",
    "displayName": "Everforest Light",
    "type": "light",
    "import": (() => __vitePreload(() => import("./everforest-light-BmTD3bxe.js"), true ? [] : void 0))
  },
  {
    "id": "github-dark",
    "displayName": "GitHub Dark",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./github-dark-O22yVQaY.js"), true ? [] : void 0))
  },
  {
    "id": "github-dark-default",
    "displayName": "GitHub Dark Default",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./github-dark-default-DB2Hkvqn.js"), true ? [] : void 0))
  },
  {
    "id": "github-dark-dimmed",
    "displayName": "GitHub Dark Dimmed",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./github-dark-dimmed-CMZ_OfqC.js"), true ? [] : void 0))
  },
  {
    "id": "github-dark-high-contrast",
    "displayName": "GitHub Dark High Contrast",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./github-dark-high-contrast-DmxWVmCU.js"), true ? [] : void 0))
  },
  {
    "id": "github-light",
    "displayName": "GitHub Light",
    "type": "light",
    "import": (() => __vitePreload(() => import("./github-light-BTbR9xVK.js"), true ? [] : void 0))
  },
  {
    "id": "github-light-default",
    "displayName": "GitHub Light Default",
    "type": "light",
    "import": (() => __vitePreload(() => import("./github-light-default-DWEonwFe.js"), true ? [] : void 0))
  },
  {
    "id": "github-light-high-contrast",
    "displayName": "GitHub Light High Contrast",
    "type": "light",
    "import": (() => __vitePreload(() => import("./github-light-high-contrast-WJ_cPDts.js"), true ? [] : void 0))
  },
  {
    "id": "gruvbox-dark-hard",
    "displayName": "Gruvbox Dark Hard",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./gruvbox-dark-hard-DVsRsETr.js"), true ? [] : void 0))
  },
  {
    "id": "gruvbox-dark-medium",
    "displayName": "Gruvbox Dark Medium",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./gruvbox-dark-medium-B5JBrQdg.js"), true ? [] : void 0))
  },
  {
    "id": "gruvbox-dark-soft",
    "displayName": "Gruvbox Dark Soft",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./gruvbox-dark-soft-Db-YOqRx.js"), true ? [] : void 0))
  },
  {
    "id": "gruvbox-light-hard",
    "displayName": "Gruvbox Light Hard",
    "type": "light",
    "import": (() => __vitePreload(() => import("./gruvbox-light-hard-CXzJt7DI.js"), true ? [] : void 0))
  },
  {
    "id": "gruvbox-light-medium",
    "displayName": "Gruvbox Light Medium",
    "type": "light",
    "import": (() => __vitePreload(() => import("./gruvbox-light-medium-B89RAI1Y.js"), true ? [] : void 0))
  },
  {
    "id": "gruvbox-light-soft",
    "displayName": "Gruvbox Light Soft",
    "type": "light",
    "import": (() => __vitePreload(() => import("./gruvbox-light-soft-Cs0hTZYv.js"), true ? [] : void 0))
  },
  {
    "id": "horizon",
    "displayName": "Horizon",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./horizon-DWzh3z5C.js"), true ? [] : void 0))
  },
  {
    "id": "houston",
    "displayName": "Houston",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./houston-CF_ws8Cq.js"), true ? [] : void 0))
  },
  {
    "id": "kanagawa-dragon",
    "displayName": "Kanagawa Dragon",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./kanagawa-dragon-DU8n2NNT.js"), true ? [] : void 0))
  },
  {
    "id": "kanagawa-lotus",
    "displayName": "Kanagawa Lotus",
    "type": "light",
    "import": (() => __vitePreload(() => import("./kanagawa-lotus-Byd0CDet.js"), true ? [] : void 0))
  },
  {
    "id": "kanagawa-wave",
    "displayName": "Kanagawa Wave",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./kanagawa-wave-DExoagcR.js"), true ? [] : void 0))
  },
  {
    "id": "laserwave",
    "displayName": "LaserWave",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./laserwave-DF03wMlf.js"), true ? [] : void 0))
  },
  {
    "id": "light-plus",
    "displayName": "Light Plus",
    "type": "light",
    "import": (() => __vitePreload(() => import("./light-plus-DS08Xg5J.js"), true ? [] : void 0))
  },
  {
    "id": "material-theme",
    "displayName": "Material Theme",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./material-theme-B8B2U48Q.js"), true ? [] : void 0))
  },
  {
    "id": "material-theme-darker",
    "displayName": "Material Theme Darker",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./material-theme-darker-BV0iY_T3.js"), true ? [] : void 0))
  },
  {
    "id": "material-theme-lighter",
    "displayName": "Material Theme Lighter",
    "type": "light",
    "import": (() => __vitePreload(() => import("./material-theme-lighter-DrzybSTF.js"), true ? [] : void 0))
  },
  {
    "id": "material-theme-ocean",
    "displayName": "Material Theme Ocean",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./material-theme-ocean-BRPLVReX.js"), true ? [] : void 0))
  },
  {
    "id": "material-theme-palenight",
    "displayName": "Material Theme Palenight",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./material-theme-palenight-DSJwsR_D.js"), true ? [] : void 0))
  },
  {
    "id": "min-dark",
    "displayName": "Min Dark",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./min-dark-BNaN9fWk.js"), true ? [] : void 0))
  },
  {
    "id": "min-light",
    "displayName": "Min Light",
    "type": "light",
    "import": (() => __vitePreload(() => import("./min-light-CMrjentn.js"), true ? [] : void 0))
  },
  {
    "id": "monokai",
    "displayName": "Monokai",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./monokai-DelygWXa.js"), true ? [] : void 0))
  },
  {
    "id": "night-owl",
    "displayName": "Night Owl",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./night-owl-DSS199ra.js"), true ? [] : void 0))
  },
  {
    "id": "night-owl-light",
    "displayName": "Night Owl Light",
    "type": "light",
    "import": (() => __vitePreload(() => import("./night-owl-light-gC6E-Eh2.js"), true ? [] : void 0))
  },
  {
    "id": "nord",
    "displayName": "Nord",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./nord-CvDbBq5M.js"), true ? [] : void 0))
  },
  {
    "id": "one-dark-pro",
    "displayName": "One Dark Pro",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./one-dark-pro-CsMf0BoJ.js"), true ? [] : void 0))
  },
  {
    "id": "one-light",
    "displayName": "One Light",
    "type": "light",
    "import": (() => __vitePreload(() => import("./one-light-B0cTzZyr.js"), true ? [] : void 0))
  },
  {
    "id": "plastic",
    "displayName": "Plastic",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./plastic-BjwMpBc0.js"), true ? [] : void 0))
  },
  {
    "id": "poimandres",
    "displayName": "Poimandres",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./poimandres-ChWyhPrn.js"), true ? [] : void 0))
  },
  {
    "id": "red",
    "displayName": "Red",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./red-DByOl5N0.js"), true ? [] : void 0))
  },
  {
    "id": "rose-pine",
    "displayName": "Ros Pine",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./rose-pine-B-kZ4Z9q.js"), true ? [] : void 0))
  },
  {
    "id": "rose-pine-dawn",
    "displayName": "Ros Pine Dawn",
    "type": "light",
    "import": (() => __vitePreload(() => import("./rose-pine-dawn-efeVGdSI.js"), true ? [] : void 0))
  },
  {
    "id": "rose-pine-moon",
    "displayName": "Ros Pine Moon",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./rose-pine-moon-DmodZNzl.js"), true ? [] : void 0))
  },
  {
    "id": "slack-dark",
    "displayName": "Slack Dark",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./slack-dark-BEe10hxO.js"), true ? [] : void 0))
  },
  {
    "id": "slack-ochin",
    "displayName": "Slack Ochin",
    "type": "light",
    "import": (() => __vitePreload(() => import("./slack-ochin-BKmu9pBc.js"), true ? [] : void 0))
  },
  {
    "id": "snazzy-light",
    "displayName": "Snazzy Light",
    "type": "light",
    "import": (() => __vitePreload(() => import("./snazzy-light-Dcvd-ZyI.js"), true ? [] : void 0))
  },
  {
    "id": "solarized-dark",
    "displayName": "Solarized Dark",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./solarized-dark-BBl5y5sR.js"), true ? [] : void 0))
  },
  {
    "id": "solarized-light",
    "displayName": "Solarized Light",
    "type": "light",
    "import": (() => __vitePreload(() => import("./solarized-light-DW9b_AY8.js"), true ? [] : void 0))
  },
  {
    "id": "synthwave-84",
    "displayName": "Synthwave '84",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./synthwave-84-CoUef9sh.js"), true ? [] : void 0))
  },
  {
    "id": "tokyo-night",
    "displayName": "Tokyo Night",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./tokyo-night-DjtLpAEY.js"), true ? [] : void 0))
  },
  {
    "id": "vesper",
    "displayName": "Vesper",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./vesper-4Q1cEwPL.js"), true ? [] : void 0))
  },
  {
    "id": "vitesse-black",
    "displayName": "Vitesse Black",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./vitesse-black-BqNLki8b.js"), true ? [] : void 0))
  },
  {
    "id": "vitesse-dark",
    "displayName": "Vitesse Dark",
    "type": "dark",
    "import": (() => __vitePreload(() => import("./vitesse-dark-jJ32WhwH.js"), true ? [] : void 0))
  },
  {
    "id": "vitesse-light",
    "displayName": "Vitesse Light",
    "type": "light",
    "import": (() => __vitePreload(() => import("./vitesse-light-476zM4e6.js"), true ? [] : void 0))
  }
];
const bundledThemes = Object.fromEntries(bundledThemesInfo.map((i) => [i.id, i.import]));
class ShikiError3 extends Error {
  constructor(message) {
    super(message);
    this.name = "ShikiError";
  }
}
function getHeapMax() {
  return 2147483648;
}
function _emscripten_get_now() {
  return typeof performance !== "undefined" ? performance.now() : Date.now();
}
const alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
async function main(init) {
  let wasmMemory;
  let buffer;
  const binding = {};
  function updateGlobalBufferAndViews(buf) {
    buffer = buf;
    binding.HEAPU8 = new Uint8Array(buf);
    binding.HEAPU32 = new Uint32Array(buf);
  }
  function _emscripten_memcpy_big(dest, src, num) {
    binding.HEAPU8.copyWithin(dest, src, src + num);
  }
  function emscripten_realloc_buffer(size) {
    try {
      wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
      updateGlobalBufferAndViews(wasmMemory.buffer);
      return 1;
    } catch {
    }
  }
  function _emscripten_resize_heap(requestedSize) {
    const oldSize = binding.HEAPU8.length;
    requestedSize = requestedSize >>> 0;
    const maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize)
      return false;
    for (let cutDown = 1; cutDown <= 4; cutDown *= 2) {
      let overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      const newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      const replacement = emscripten_realloc_buffer(newSize);
      if (replacement)
        return true;
    }
    return false;
  }
  const UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead = 1024) {
    const endIdx = idx + maxBytesToRead;
    let endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    let str = "";
    while (idx < endPtr) {
      let u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      const u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) === 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      const u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) === 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        const ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  }
  function UTF8ToString(ptr, maxBytesToRead) {
    return ptr ? UTF8ArrayToString(binding.HEAPU8, ptr, maxBytesToRead) : "";
  }
  const asmLibraryArg = {
    emscripten_get_now: _emscripten_get_now,
    emscripten_memcpy_big: _emscripten_memcpy_big,
    emscripten_resize_heap: _emscripten_resize_heap,
    fd_write: () => 0
  };
  async function createWasm() {
    const info = {
      env: asmLibraryArg,
      wasi_snapshot_preview1: asmLibraryArg
    };
    const exports$1 = await init(info);
    wasmMemory = exports$1.memory;
    updateGlobalBufferAndViews(wasmMemory.buffer);
    Object.assign(binding, exports$1);
    binding.UTF8ToString = UTF8ToString;
  }
  await createWasm();
  return binding;
}
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
let onigBinding = null;
function throwLastOnigError(onigBinding2) {
  throw new ShikiError3(onigBinding2.UTF8ToString(onigBinding2.getLastOnigError()));
}
class UtfString {
  constructor(str) {
    __publicField(this, "utf16Length");
    __publicField(this, "utf8Length");
    __publicField(this, "utf16Value");
    __publicField(this, "utf8Value");
    __publicField(this, "utf16OffsetToUtf8");
    __publicField(this, "utf8OffsetToUtf16");
    const utf16Length = str.length;
    const utf8Length = UtfString._utf8ByteLength(str);
    const computeIndicesMapping = utf8Length !== utf16Length;
    const utf16OffsetToUtf8 = computeIndicesMapping ? new Uint32Array(utf16Length + 1) : null;
    if (computeIndicesMapping)
      utf16OffsetToUtf8[utf16Length] = utf8Length;
    const utf8OffsetToUtf16 = computeIndicesMapping ? new Uint32Array(utf8Length + 1) : null;
    if (computeIndicesMapping)
      utf8OffsetToUtf16[utf8Length] = utf16Length;
    const utf8Value = new Uint8Array(utf8Length);
    let i8 = 0;
    for (let i16 = 0; i16 < utf16Length; i16++) {
      const charCode = str.charCodeAt(i16);
      let codePoint = charCode;
      let wasSurrogatePair = false;
      if (charCode >= 55296 && charCode <= 56319) {
        if (i16 + 1 < utf16Length) {
          const nextCharCode = str.charCodeAt(i16 + 1);
          if (nextCharCode >= 56320 && nextCharCode <= 57343) {
            codePoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;
            wasSurrogatePair = true;
          }
        }
      }
      if (computeIndicesMapping) {
        utf16OffsetToUtf8[i16] = i8;
        if (wasSurrogatePair)
          utf16OffsetToUtf8[i16 + 1] = i8;
        if (codePoint <= 127) {
          utf8OffsetToUtf16[i8 + 0] = i16;
        } else if (codePoint <= 2047) {
          utf8OffsetToUtf16[i8 + 0] = i16;
          utf8OffsetToUtf16[i8 + 1] = i16;
        } else if (codePoint <= 65535) {
          utf8OffsetToUtf16[i8 + 0] = i16;
          utf8OffsetToUtf16[i8 + 1] = i16;
          utf8OffsetToUtf16[i8 + 2] = i16;
        } else {
          utf8OffsetToUtf16[i8 + 0] = i16;
          utf8OffsetToUtf16[i8 + 1] = i16;
          utf8OffsetToUtf16[i8 + 2] = i16;
          utf8OffsetToUtf16[i8 + 3] = i16;
        }
      }
      if (codePoint <= 127) {
        utf8Value[i8++] = codePoint;
      } else if (codePoint <= 2047) {
        utf8Value[i8++] = 192 | (codePoint & 1984) >>> 6;
        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
      } else if (codePoint <= 65535) {
        utf8Value[i8++] = 224 | (codePoint & 61440) >>> 12;
        utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;
        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
      } else {
        utf8Value[i8++] = 240 | (codePoint & 1835008) >>> 18;
        utf8Value[i8++] = 128 | (codePoint & 258048) >>> 12;
        utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;
        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
      }
      if (wasSurrogatePair)
        i16++;
    }
    this.utf16Length = utf16Length;
    this.utf8Length = utf8Length;
    this.utf16Value = str;
    this.utf8Value = utf8Value;
    this.utf16OffsetToUtf8 = utf16OffsetToUtf8;
    this.utf8OffsetToUtf16 = utf8OffsetToUtf16;
  }
  static _utf8ByteLength(str) {
    let result = 0;
    for (let i = 0, len = str.length; i < len; i++) {
      const charCode = str.charCodeAt(i);
      let codepoint = charCode;
      let wasSurrogatePair = false;
      if (charCode >= 55296 && charCode <= 56319) {
        if (i + 1 < len) {
          const nextCharCode = str.charCodeAt(i + 1);
          if (nextCharCode >= 56320 && nextCharCode <= 57343) {
            codepoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;
            wasSurrogatePair = true;
          }
        }
      }
      if (codepoint <= 127)
        result += 1;
      else if (codepoint <= 2047)
        result += 2;
      else if (codepoint <= 65535)
        result += 3;
      else
        result += 4;
      if (wasSurrogatePair)
        i++;
    }
    return result;
  }
  createString(onigBinding2) {
    const result = onigBinding2.omalloc(this.utf8Length);
    onigBinding2.HEAPU8.set(this.utf8Value, result);
    return result;
  }
}
const _OnigString = class _OnigString2 {
  constructor(str) {
    __publicField(this, "id", ++_OnigString2.LAST_ID);
    __publicField(this, "_onigBinding");
    __publicField(this, "content");
    __publicField(this, "utf16Length");
    __publicField(this, "utf8Length");
    __publicField(this, "utf16OffsetToUtf8");
    __publicField(this, "utf8OffsetToUtf16");
    __publicField(this, "ptr");
    if (!onigBinding)
      throw new ShikiError3("Must invoke loadWasm first.");
    this._onigBinding = onigBinding;
    this.content = str;
    const utfString = new UtfString(str);
    this.utf16Length = utfString.utf16Length;
    this.utf8Length = utfString.utf8Length;
    this.utf16OffsetToUtf8 = utfString.utf16OffsetToUtf8;
    this.utf8OffsetToUtf16 = utfString.utf8OffsetToUtf16;
    if (this.utf8Length < 1e4 && !_OnigString2._sharedPtrInUse) {
      if (!_OnigString2._sharedPtr)
        _OnigString2._sharedPtr = onigBinding.omalloc(1e4);
      _OnigString2._sharedPtrInUse = true;
      onigBinding.HEAPU8.set(utfString.utf8Value, _OnigString2._sharedPtr);
      this.ptr = _OnigString2._sharedPtr;
    } else {
      this.ptr = utfString.createString(onigBinding);
    }
  }
  convertUtf8OffsetToUtf16(utf8Offset) {
    if (this.utf8OffsetToUtf16) {
      if (utf8Offset < 0)
        return 0;
      if (utf8Offset > this.utf8Length)
        return this.utf16Length;
      return this.utf8OffsetToUtf16[utf8Offset];
    }
    return utf8Offset;
  }
  convertUtf16OffsetToUtf8(utf16Offset) {
    if (this.utf16OffsetToUtf8) {
      if (utf16Offset < 0)
        return 0;
      if (utf16Offset > this.utf16Length)
        return this.utf8Length;
      return this.utf16OffsetToUtf8[utf16Offset];
    }
    return utf16Offset;
  }
  dispose() {
    if (this.ptr === _OnigString2._sharedPtr)
      _OnigString2._sharedPtrInUse = false;
    else
      this._onigBinding.ofree(this.ptr);
  }
};
__publicField(_OnigString, "LAST_ID", 0);
__publicField(_OnigString, "_sharedPtr", 0);
__publicField(_OnigString, "_sharedPtrInUse", false);
let OnigString = _OnigString;
class OnigScanner {
  constructor(patterns) {
    __publicField(this, "_onigBinding");
    __publicField(this, "_ptr");
    if (!onigBinding)
      throw new ShikiError3("Must invoke loadWasm first.");
    const strPtrsArr = [];
    const strLenArr = [];
    for (let i = 0, len = patterns.length; i < len; i++) {
      const utfString = new UtfString(patterns[i]);
      strPtrsArr[i] = utfString.createString(onigBinding);
      strLenArr[i] = utfString.utf8Length;
    }
    const strPtrsPtr = onigBinding.omalloc(4 * patterns.length);
    onigBinding.HEAPU32.set(strPtrsArr, strPtrsPtr / 4);
    const strLenPtr = onigBinding.omalloc(4 * patterns.length);
    onigBinding.HEAPU32.set(strLenArr, strLenPtr / 4);
    const scannerPtr = onigBinding.createOnigScanner(strPtrsPtr, strLenPtr, patterns.length);
    for (let i = 0, len = patterns.length; i < len; i++)
      onigBinding.ofree(strPtrsArr[i]);
    onigBinding.ofree(strLenPtr);
    onigBinding.ofree(strPtrsPtr);
    if (scannerPtr === 0)
      throwLastOnigError(onigBinding);
    this._onigBinding = onigBinding;
    this._ptr = scannerPtr;
  }
  dispose() {
    this._onigBinding.freeOnigScanner(this._ptr);
  }
  findNextMatchSync(string, startPosition, arg) {
    let options = 0;
    if (typeof arg === "number") {
      options = arg;
    }
    if (typeof string === "string") {
      string = new OnigString(string);
      const result = this._findNextMatchSync(string, startPosition, false, options);
      string.dispose();
      return result;
    }
    return this._findNextMatchSync(string, startPosition, false, options);
  }
  _findNextMatchSync(string, startPosition, debugCall, options) {
    const onigBinding2 = this._onigBinding;
    const resultPtr = onigBinding2.findNextOnigScannerMatch(this._ptr, string.id, string.ptr, string.utf8Length, string.convertUtf16OffsetToUtf8(startPosition), options);
    if (resultPtr === 0) {
      return null;
    }
    const HEAPU32 = onigBinding2.HEAPU32;
    let offset = resultPtr / 4;
    const index = HEAPU32[offset++];
    const count = HEAPU32[offset++];
    const captureIndices = [];
    for (let i = 0; i < count; i++) {
      const beg = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);
      const end = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);
      captureIndices[i] = {
        start: beg,
        end,
        length: end - beg
      };
    }
    return {
      index,
      captureIndices
    };
  }
}
function isInstantiatorOptionsObject(dataOrOptions) {
  return typeof dataOrOptions.instantiator === "function";
}
function isInstantiatorModule(dataOrOptions) {
  return typeof dataOrOptions.default === "function";
}
function isDataOptionsObject(dataOrOptions) {
  return typeof dataOrOptions.data !== "undefined";
}
function isResponse(dataOrOptions) {
  return typeof Response !== "undefined" && dataOrOptions instanceof Response;
}
function isArrayBuffer(data) {
  return typeof ArrayBuffer !== "undefined" && (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) || typeof Buffer !== "undefined" && Buffer.isBuffer?.(data) || typeof SharedArrayBuffer !== "undefined" && data instanceof SharedArrayBuffer || typeof Uint32Array !== "undefined" && data instanceof Uint32Array;
}
let initPromise;
function loadWasm(options) {
  if (initPromise)
    return initPromise;
  async function _load() {
    onigBinding = await main(async (info) => {
      let instance = options;
      instance = await instance;
      if (typeof instance === "function")
        instance = await instance(info);
      if (typeof instance === "function")
        instance = await instance(info);
      if (isInstantiatorOptionsObject(instance)) {
        instance = await instance.instantiator(info);
      } else if (isInstantiatorModule(instance)) {
        instance = await instance.default(info);
      } else {
        if (isDataOptionsObject(instance))
          instance = instance.data;
        if (isResponse(instance)) {
          if (typeof WebAssembly.instantiateStreaming === "function")
            instance = await _makeResponseStreamingLoader(instance)(info);
          else
            instance = await _makeResponseNonStreamingLoader(instance)(info);
        } else if (isArrayBuffer(instance)) {
          instance = await _makeArrayBufferLoader(instance)(info);
        } else if (instance instanceof WebAssembly.Module) {
          instance = await _makeArrayBufferLoader(instance)(info);
        } else if ("default" in instance && instance.default instanceof WebAssembly.Module) {
          instance = await _makeArrayBufferLoader(instance.default)(info);
        }
      }
      if ("instance" in instance)
        instance = instance.instance;
      if ("exports" in instance)
        instance = instance.exports;
      return instance;
    });
  }
  initPromise = _load();
  return initPromise;
}
function _makeArrayBufferLoader(data) {
  return (importObject) => WebAssembly.instantiate(data, importObject);
}
function _makeResponseStreamingLoader(data) {
  return (importObject) => WebAssembly.instantiateStreaming(data, importObject);
}
function _makeResponseNonStreamingLoader(data) {
  return async (importObject) => {
    const arrayBuffer = await data.arrayBuffer();
    return WebAssembly.instantiate(arrayBuffer, importObject);
  };
}
async function createOnigurumaEngine(options) {
  if (options)
    await loadWasm(options);
  return {
    createScanner(patterns) {
      return new OnigScanner(patterns.map((p) => typeof p === "string" ? p : p.source));
    },
    createString(s) {
      return new OnigString(s);
    }
  };
}
const createHighlighter = /* @__PURE__ */ createBundledHighlighter({
  langs: bundledLanguages,
  themes: bundledThemes,
  engine: () => createOnigurumaEngine(__vitePreload(() => import("./wasm-DDgzZJey.js"), true ? [] : void 0))
});
const _hoisted_1$h = { class: "histoire-story-source-code htw-bg-gray-50 dark:htw-bg-gray-750 htw-h-full htw-overflow-hidden htw-flex htw-flex-col" };
const _hoisted_2$8 = {
  key: 0,
  class: "htw-h-10 htw-flex-none htw-border-b htw-border-solid htw-border-gray-500/5 htw-px-4 htw-flex htw-items-center htw-gap-2"
};
const _hoisted_3$7 = { class: "htw-flex htw-flex-none htw-gap-px htw-h-full htw-py-2" };
const _hoisted_4$4 = {
  key: 1,
  class: "htw-text-red-500 htw-h-full htw-p-2 htw-overflow-auto htw-font-mono htw-text-sm"
};
const _hoisted_5$4 = ["value"];
const _hoisted_6$2 = ["innerHTML"];
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "StorySourceCode",
  props: {
    story: {},
    variant: {}
  },
  setup(__props) {
    const props = __props;
    const generateSourceCodeFn = ref(null);
    watchEffect(async () => {
      const clientPlugin = clientSupportPlugins[props.story.file?.supportPluginId];
      if (clientPlugin) {
        const pluginModule = await clientPlugin();
        generateSourceCodeFn.value = markRaw(pluginModule.generateSourceCode);
      }
    });
    const highlighter = shallowRef();
    const dynamicSourceCode = ref("");
    const error = ref(null);
    watch(() => [props.variant, generateSourceCodeFn.value], async () => {
      if (!generateSourceCodeFn.value) return;
      error.value = null;
      dynamicSourceCode.value = "";
      try {
        if (props.variant.source) {
          dynamicSourceCode.value = props.variant.source;
        } else if (props.variant.slots?.().source) {
          const source = props.variant.slots?.().source()[0].children;
          if (source) {
            dynamicSourceCode.value = await unindent(source);
          }
        } else {
          dynamicSourceCode.value = await generateSourceCodeFn.value(props.variant);
        }
      } catch (e) {
        console.error(e);
        error.value = e.message;
      }
      if (!dynamicSourceCode.value) {
        displayedSource.value = "static";
      }
    }, {
      deep: true,
      immediate: true
    });
    const staticSourceCode = ref("");
    watch(() => [props.story, props.story?.file?.source], async () => {
      staticSourceCode.value = "";
      const sourceLoader = props.story.file?.source;
      if (sourceLoader) {
        staticSourceCode.value = (await sourceLoader()).default;
      }
    }, {
      immediate: true
    });
    const displayedSource = ref("dynamic");
    const displayedSourceCode = computed(() => {
      if (displayedSource.value === "dynamic") {
        return dynamicSourceCode.value;
      }
      return staticSourceCode.value;
    });
    onMounted(async () => {
      highlighter.value = await createHighlighter({
        langs: [
          "html",
          "jsx"
        ],
        themes: [
          "github-light",
          "github-dark"
        ]
      });
    });
    const sourceHtml = computed(() => displayedSourceCode.value ? highlighter.value?.codeToHtml(displayedSourceCode.value, {
      lang: "html",
      theme: isDark.value ? "github-dark" : "github-light"
    }) : "");
    let lastScroll = 0;
    watch(() => props.variant, () => {
      lastScroll = 0;
    });
    const scroller = ref();
    function onScroll(event) {
      if (sourceHtml.value) {
        lastScroll = event.target.scrollTop;
      }
    }
    watch(sourceHtml, async () => {
      await nextTick();
      if (scroller.value) {
        scroller.value.scrollTop = lastScroll;
      }
    });
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock("div", _hoisted_1$h, [
        !error.value ? (openBlock(), createElementBlock("div", _hoisted_2$8, [
          _cache[2] || (_cache[2] = createBaseVNode("div", { class: "htw-text-gray-900 dark:htw-text-gray-100" }, " Source ", -1)),
          _cache[3] || (_cache[3] = createBaseVNode("div", { class: "htw-flex-1" }, null, -1)),
          createBaseVNode("div", _hoisted_3$7, [
            withDirectives((openBlock(), createElementBlock("button", {
              class: normalizeClass(["htw-flex htw-items-center htw-gap-1 htw-h-full htw-px-1 htw-bg-gray-500/10 htw-rounded-l htw-transition-all htw-ease-[cubic-bezier(0,1,.6,1)] htw-duration-300 htw-overflow-hidden", [
                displayedSource.value !== "dynamic" ? "htw-max-w-6 htw-opacity-70" : "htw-max-w-[82px] htw-text-primary-600 dark:htw-text-primary-400",
                dynamicSourceCode.value ? "htw-cursor-pointer hover:htw-bg-gray-500/30 active:htw-bg-gray-600/50" : "htw-opacity-50"
              ]]),
              onClick: _cache[0] || (_cache[0] = ($event) => dynamicSourceCode.value && (displayedSource.value = "dynamic"))
            }, [
              createVNode(unref(Icon), {
                icon: "carbon:flash",
                class: "htw-w-4 htw-h-4 htw-flex-none"
              }),
              createBaseVNode("span", {
                class: normalizeClass(["transition-opacity duration-300", {
                  "opacity-0": displayedSource.value !== "dynamic"
                }])
              }, " Dynamic ", 2)
            ], 2)), [
              [_directive_tooltip, !dynamicSourceCode.value ? "Dynamic source code is not available" : displayedSource.value !== "dynamic" ? "Switch to dynamic source" : null]
            ]),
            withDirectives((openBlock(), createElementBlock("button", {
              class: normalizeClass(["htw-flex htw-items-center htw-gap-1 htw-h-full htw-px-1 htw-bg-gray-500/10 htw-rounded-r htw-transition-all htw-ease-[cubic-bezier(0,1,.6,1)] htw-duration-300 htw-overflow-hidden", [
                displayedSource.value !== "static" ? "htw-max-w-6 htw-opacity-70" : "htw-max-w-[63px] htw-text-primary-600 dark:htw-text-primary-400",
                staticSourceCode.value ? "htw-cursor-pointer hover:htw-bg-gray-500/30 active:htw-bg-gray-600/50" : "htw-opacity-50"
              ]]),
              onClick: _cache[1] || (_cache[1] = ($event) => staticSourceCode.value && (displayedSource.value = "static"))
            }, [
              createVNode(unref(Icon), {
                icon: "carbon:document",
                class: "htw-w-4 htw-h-4 htw-flex-none"
              }),
              createBaseVNode("span", {
                class: normalizeClass(["transition-opacity duration-300", {
                  "opacity-0": displayedSource.value !== "static"
                }])
              }, " Static ", 2)
            ], 2)), [
              [_directive_tooltip, !staticSourceCode.value ? "Static source code is not available" : displayedSource.value !== "static" ? "Switch to static source" : null]
            ])
          ]),
          createVNode(unref(f0), {
            content: displayedSourceCode.value,
            class: "htw-flex-none"
          }, null, 8, ["content"])
        ])) : createCommentVNode("", true),
        error.value ? (openBlock(), createElementBlock("div", _hoisted_4$4, " Error: " + toDisplayString(error.value), 1)) : !displayedSourceCode.value ? (openBlock(), createBlock(BaseEmpty, { key: 2 }, {
          default: withCtx(() => [
            createVNode(unref(Icon), {
              icon: "carbon:code-hide",
              class: "htw-w-8 htw-h-8 htw-opacity-50 htw-mb-6"
            }),
            _cache[4] || (_cache[4] = createBaseVNode("span", null, "Not available", -1))
          ]),
          _: 1
        })) : !sourceHtml.value ? (openBlock(), createElementBlock("textarea", {
          key: 3,
          ref_key: "scroller",
          ref: scroller,
          class: "__histoire-code-placeholder htw-w-full htw-h-full htw-p-4 htw-outline-none htw-bg-transparent htw-resize-none htw-m-0",
          value: displayedSourceCode.value,
          readonly: "",
          "data-test-id": "story-source-code",
          onScroll
        }, null, 40, _hoisted_5$4)) : (openBlock(), createElementBlock("div", {
          key: 4,
          ref_key: "scroller",
          ref: scroller,
          class: "htw-w-full htw-h-full htw-overflow-auto",
          "data-test-id": "story-source-code",
          onScroll
        }, [
          createBaseVNode("div", {
            class: "__histoire-code htw-p-4 htw-w-fit",
            innerHTML: sourceHtml.value
          }, null, 8, _hoisted_6$2)
        ], 544))
      ]);
    };
  }
});
const StorySourceCode = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__scopeId", "data-v-96af7f40"]]);
const _hoisted_1$g = { class: "htw-flex htw-flex-col htw-h-full" };
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "StorySidePanel",
  setup(__props) {
    const storyStore = useStoryStore();
    const route = useRoute();
    const panelContentComponent = computed(() => {
      switch (route.query.tab) {
        case "docs":
          return _sfc_main$y;
        case "events":
          return _sfc_main$k;
        default:
          return _sfc_main$m;
      }
    });
    return (_ctx, _cache) => {
      return !unref(storyStore).currentVariant ? (openBlock(), createBlock(BaseEmpty, {
        key: 0,
        class: "histoire-story-side-panel histoire-selection"
      }, {
        default: withCtx(() => [..._cache[0] || (_cache[0] = [
          createBaseVNode("span", null, "Select a variant", -1)
        ])]),
        _: 1
      })) : !unref(storyStore).currentVariant.configReady || !unref(storyStore).currentVariant.previewReady ? (openBlock(), createBlock(BaseEmpty, {
        key: 1,
        class: "histoire-story-side-panel histoire-loading"
      }, {
        default: withCtx(() => [..._cache[1] || (_cache[1] = [
          createBaseVNode("span", null, "Loading...", -1)
        ])]),
        _: 1
      })) : (openBlock(), createBlock(BaseSplitPane, {
        key: 2,
        "save-id": "story-sidepane",
        orientation: "portrait",
        class: "histoire-story-side-panel histoire-loaded htw-h-full",
        "data-test-id": "story-side-panel"
      }, {
        first: withCtx(() => [
          createBaseVNode("div", _hoisted_1$g, [
            createVNode(_sfc_main$t, {
              story: unref(storyStore).currentStory,
              variant: unref(storyStore).currentVariant
            }, null, 8, ["story", "variant"]),
            (openBlock(), createBlock(resolveDynamicComponent(panelContentComponent.value), {
              story: unref(storyStore).currentStory,
              variant: unref(storyStore).currentVariant,
              class: "htw-h-full htw-overflow-auto"
            }, null, 8, ["story", "variant"]))
          ])
        ]),
        last: withCtx(() => [
          createVNode(StorySourceCode, {
            story: unref(storyStore).currentStory,
            variant: unref(storyStore).currentVariant,
            class: "htw-h-full"
          }, null, 8, ["story", "variant"])
        ]),
        _: 1
      }));
    };
  }
});
const usePreviewSettingsStore = defineStore("preview-settings", () => {
  const currentSettings = useStorage("_histoire-sandbox-settings-v3", {
    responsiveWidth: 720,
    responsiveHeight: null,
    rotate: false,
    backgroundColor: "transparent",
    checkerboard: false,
    textDirection: "ltr"
  });
  return {
    currentSettings
  };
});
const _hoisted_1$f = { class: "htw-text-white htw-w-[16px] htw-h-[16px] htw-relative" };
const _hoisted_2$7 = {
  width: "16",
  height: "16",
  viewBox: "0 0 24 24",
  class: "htw-relative htw-z-10"
};
const _hoisted_3$6 = ["stroke-dasharray", "stroke-dashoffset"];
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "BaseCheckbox",
  props: {
    modelValue: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:modelValue": (_newValue) => true
  },
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    function toggle() {
      emit("update:modelValue", !props.modelValue);
      animationEnabled.value = true;
    }
    const path = ref();
    const dasharray = ref(0);
    const progress = computed(() => props.modelValue ? 1 : 0);
    const dashoffset = computed(() => (1 - progress.value) * dasharray.value);
    const animationEnabled = ref(false);
    watch(path, () => {
      dasharray.value = path.value.getTotalLength?.() ?? 21.21;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        role: "checkbox",
        tabindex: "0",
        class: "histoire-base-checkbox htw-flex htw-items-center htw-gap-2 htw-select-none htw-px-4 htw-py-3 htw-cursor-pointer hover:htw-bg-primary-100 dark:hover:htw-bg-primary-700",
        onClick: _cache[0] || (_cache[0] = ($event) => toggle()),
        onKeydown: [
          _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => toggle(), ["prevent"]), ["enter"])),
          _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => toggle(), ["prevent"]), ["space"]))
        ]
      }, [
        createBaseVNode("div", _hoisted_1$f, [
          createBaseVNode("div", {
            class: normalizeClass(["htw-border group-active:htw-bg-gray-500/20 htw-rounded-sm htw-box-border htw-absolute htw-inset-0 htw-transition-border htw-duration-150 htw-ease-out", [
              __props.modelValue ? "htw-border-primary-500 htw-border-8" : "htw-border-black/25 dark:htw-border-white/25 htw-delay-150"
            ]])
          }, null, 2),
          (openBlock(), createElementBlock("svg", _hoisted_2$7, [
            createBaseVNode("path", {
              ref_key: "path",
              ref: path,
              d: "m 4 12 l 5 5 l 10 -10",
              fill: "none",
              class: normalizeClass(["htw-stroke-white htw-stroke-2 htw-duration-200 htw-ease-in-out", [
                animationEnabled.value ? "htw-transition-all" : "htw-transition-none",
                {
                  "htw-delay-150": __props.modelValue
                }
              ]]),
              "stroke-dasharray": dasharray.value,
              "stroke-dashoffset": dashoffset.value
            }, null, 10, _hoisted_3$6)
          ]))
        ]),
        renderSlot(_ctx.$slots, "default")
      ], 32);
    };
  }
});
const _hoisted_1$e = { class: "htw-cursor-pointer hover:htw-text-primary-500 htw-flex htw-items-center htw-gap-1 htw-h-full htw-px-2 htw-group" };
const _hoisted_2$6 = { class: "bind-preview-bg htw-w-4 htw-h-4 htw-rounded-full htw-border htw-border-black/50 dark:htw-border-white/50 htw-flex htw-items-center htw-justify-center htw-text-xs" };
const _hoisted_3$5 = { key: 0 };
const _hoisted_4$3 = {
  class: "htw-flex htw-flex-col htw-items-stretch",
  "data-test-id": "background-popper"
};
const _hoisted_5$3 = ["onClick"];
const _hoisted_6$1 = { class: "htw-mr-auto" };
const _hoisted_7$1 = { class: "htw-ml-auto htw-opacity-70" };
const _hoisted_8$1 = { key: 0 };
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "ToolbarBackground",
  setup(__props) {
    useCssVars((_ctx) => ({
      "v627bec82": unref(settings).backgroundColor,
      "v35068428": contrastColor.value
    }));
    const settings = usePreviewSettingsStore().currentSettings;
    const contrastColor = computed(() => getContrastColor(settings));
    return (_ctx, _cache) => {
      const _component_VDropdown = resolveComponent("VDropdown");
      const _directive_tooltip = resolveDirective("tooltip");
      return unref(histoireConfig).backgroundPresets.length ? (openBlock(), createBlock(_component_VDropdown, {
        key: 0,
        placement: "bottom-end",
        skidding: 6,
        class: "histoire-toolbar-background htw-h-full htw-flex-none",
        "data-test-id": "toolbar-background"
      }, {
        popper: withCtx(({ hide }) => [
          createBaseVNode("div", _hoisted_4$3, [
            createVNode(_sfc_main$h, {
              modelValue: unref(settings).checkerboard,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(settings).checkerboard = $event)
            }, {
              default: withCtx(() => [..._cache[1] || (_cache[1] = [
                createTextVNode(" Checkerboard ", -1)
              ])]),
              _: 1
            }, 8, ["modelValue"]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(histoireConfig).backgroundPresets, (option, index) => {
              return openBlock(), createElementBlock("button", {
                key: index,
                class: normalizeClass(["htw-px-4 htw-py-3 htw-cursor-pointer htw-text-left htw-flex htw-items-baseline htw-gap-4", [
                  unref(settings).backgroundColor === option.color ? "htw-bg-primary-500 hover:htw-bg-primary-600 htw-text-white dark:htw-text-black" : "htw-bg-transparent hover:htw-bg-primary-100 dark:hover:htw-bg-primary-700"
                ]]),
                onClick: ($event) => {
                  unref(settings).backgroundColor = option.color;
                  hide();
                }
              }, [
                createBaseVNode("span", _hoisted_6$1, toDisplayString(option.label), 1),
                option.color !== "$checkerboard" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createBaseVNode("span", _hoisted_7$1, toDisplayString(option.color), 1),
                  createBaseVNode("div", {
                    class: "htw-w-4 htw-h-4 htw-rounded-full htw-border htw-border-black/20 dark:htw-border-white/20 htw-flex htw-items-center htw-justify-center htw-text-xs",
                    style: normalizeStyle({
                      backgroundColor: option.color,
                      color: option.contrastColor
                    })
                  }, [
                    option.contrastColor ? (openBlock(), createElementBlock("span", _hoisted_8$1, "a")) : createCommentVNode("", true)
                  ], 4)
                ], 64)) : createCommentVNode("", true)
              ], 10, _hoisted_5$3);
            }), 128))
          ])
        ]),
        default: withCtx(() => [
          withDirectives((openBlock(), createElementBlock("div", _hoisted_1$e, [
            createBaseVNode("div", _hoisted_2$6, [
              contrastColor.value ? (openBlock(), createElementBlock("span", _hoisted_3$5, "a")) : createCommentVNode("", true)
            ]),
            createVNode(unref(Icon), {
              icon: "carbon:caret-down",
              class: "htw-w-4 htw-h-4 htw-opacity-50 group-hover:htw-opacity-100"
            })
          ])), [
            [_directive_tooltip, "Background color"]
          ])
        ]),
        _: 1
      })) : createCommentVNode("", true);
    };
  }
});
const ToolbarBackground = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-c48fb2b2"]]);
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "ToolbarTextDirection",
  setup(__props) {
    const settings = usePreviewSettingsStore().currentSettings;
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return withDirectives((openBlock(), createElementBlock("a", {
        class: "histoire-toolbar-text-direction htw-flex htw-items-center htw-gap-1 htw-h-full htw-px-2 hover:htw-text-primary-500 htw-opacity-50 hover:htw-opacity-100 dark:hover:htw-text-primary-400 htw-text-gray-900 dark:htw-text-gray-100",
        onClick: _cache[0] || (_cache[0] = ($event) => unref(settings).textDirection = unref(settings).textDirection === "ltr" ? "rtl" : "ltr")
      }, [
        createVNode(unref(Icon), {
          icon: unref(settings).textDirection === "ltr" ? "fluent:text-paragraph-direction-right-16-regular" : "fluent:text-paragraph-direction-left-16-regular",
          class: "htw-w-4 htw-h-4"
        }, null, 8, ["icon"])
      ])), [
        [_directive_tooltip, `Switch to text direction ${unref(settings).textDirection === "ltr" ? "Right to Left" : "Left to Right"}`]
      ]);
    };
  }
});
async function getSourceCode(story, variant) {
  if (variant.source) {
    return variant.source;
  } else if (variant.slots?.().source) {
    const source = variant.slots?.().source()[0].children;
    if (source) {
      return unindent(source);
    }
  } else {
    const clientPlugin = clientSupportPlugins[story.file?.supportPluginId];
    if (clientPlugin) {
      const pluginModule = await clientPlugin();
      return pluginModule.generateSourceCode(variant);
    }
  }
  const sourceLoader = story.file?.source;
  if (sourceLoader) {
    return (await sourceLoader()).default;
  }
}
function useCurrentVariantRoute(variant) {
  const route = useRoute();
  const isActive = computed(() => route.query.variantId === variant.value.id);
  const targetRoute = computed(() => ({
    ...route,
    query: {
      ...route.query,
      variantId: variant.value.id
    }
  }));
  return {
    isActive,
    targetRoute
  };
}
const _sfc_main$e = {};
const _hoisted_1$d = { fill: "none" };
function _sfc_render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$d, [..._cache[0] || (_cache[0] = [
    createBaseVNode("pattern", {
      id: "checkerboard",
      width: "64",
      height: "64",
      patternUnits: "userSpaceOnUse"
    }, [
      createBaseVNode("rect", {
        x: "0",
        y: "0",
        width: "32",
        height: "32",
        fill: "currentColor"
      }),
      createBaseVNode("rect", {
        x: "32",
        y: "32",
        width: "32",
        height: "32",
        fill: "currentColor"
      })
    ], -1),
    createBaseVNode("rect", {
      x: "0",
      y: "0",
      width: "100%",
      height: "100%",
      fill: "url(#checkerboard)"
    }, null, -1)
  ])]);
}
const CheckerboardPattern = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$1]]);
function getSandboxUrl(story, variant) {
  const url = new URLSearchParams();
  url.append("storyId", story.id);
  url.append("variantId", variant.id);
  return `${base}__sandbox.html?${url.toString()}`;
}
const _hoisted_1$c = ["href"];
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "ToolbarNewTab",
  props: {
    variant: {},
    story: {}
  },
  setup(__props) {
    const props = __props;
    const sandboxUrl = computed(() => {
      return getSandboxUrl(props.story, props.variant);
    });
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return withDirectives((openBlock(), createElementBlock("a", {
        href: sandboxUrl.value,
        target: "_blank",
        class: "histoire-toolbar-new-tab htw-flex htw-items-center htw-gap-1 htw-h-full htw-px-2 hover:htw-text-primary-500 htw-opacity-50 hover:htw-opacity-100 dark:hover:htw-text-primary-400 htw-text-gray-900 dark:htw-text-gray-100"
      }, [
        createVNode(unref(Icon), {
          icon: "carbon:launch",
          class: "htw-w-4 htw-h-4"
        })
      ], 8, _hoisted_1$c)), [
        [_directive_tooltip, "Open variant in new tab"]
      ]);
    };
  }
});
const _hoisted_1$b = { class: "htw-flex-none htw-flex htw-items-center" };
const _hoisted_2$5 = { class: "htw-truncate htw-flex-1" };
const _hoisted_3$4 = { class: "htw-flex-none htw-ml-auto htw-hidden group-hover:htw-flex htw-items-center" };
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "StoryVariantGridItem",
  props: {
    variant: {
      type: Object,
      required: true
    },
    story: {
      type: Object,
      required: true
    }
  },
  emits: {
    resize: (_width, _height) => true
  },
  setup(__props, { emit: __emit }) {
    useCssVars((_ctx) => ({
      "v60afaf4d": unref(variant).iconColor,
      "v3bd99e7e": unref(settings).backgroundColor
    }));
    const props = __props;
    const emit = __emit;
    const { variant } = toRefs(props);
    const { isActive, targetRoute } = useCurrentVariantRoute(variant);
    Object.assign(props.variant, {
      previewReady: false
    });
    function onReady() {
      Object.assign(props.variant, {
        previewReady: true
      });
    }
    const router = useRouter();
    function selectVariant() {
      router.push(targetRoute.value);
    }
    const el = ref();
    const { autoScroll } = useScrollOnActive(isActive, el);
    useResizeObserver(el, () => {
      if (props.variant.previewReady) {
        emit("resize", el.value.clientWidth, el.value.clientHeight);
        if (isActive.value) {
          autoScroll();
        }
      }
    });
    const settings = usePreviewSettingsStore().currentSettings;
    const contrastColor = computed(() => getContrastColor(settings));
    const autoApplyContrastColor = computed(() => !!histoireConfig.autoApplyContrastColor);
    return (_ctx, _cache) => {
      const _component_RouterLink = resolveComponent("RouterLink");
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock("div", {
        ref_key: "el",
        ref: el,
        class: "histoire-story-variant-grid-item htw-cursor-default htw-flex htw-flex-col htw-gap-y-1 htw-group"
      }, [
        createBaseVNode("div", _hoisted_1$b, [
          withDirectives((openBlock(), createBlock(_component_RouterLink, {
            to: unref(targetRoute),
            class: normalizeClass(["htw-rounded htw-w-max htw-px-2 htw-py-0.5 htw-min-w-16 htw-cursor-pointer htw-flex htw-items-center htw-gap-1 htw-flex-shrink", {
              "hover:htw-bg-gray-200 htw-text-gray-500 dark:hover:htw-bg-gray-800": !unref(isActive),
              "htw-bg-primary-200 hover:htw-bg-primary-300 htw-text-primary-800 dark:htw-bg-primary-700 dark:hover:htw-bg-primary-800 dark:htw-text-primary-200": unref(isActive)
            }])
          }, {
            default: withCtx(() => [
              createVNode(unref(Icon), {
                icon: unref(variant).icon ?? "carbon:cube",
                class: normalizeClass(["htw-w-4 htw-h-4 htw-opacity-50", {
                  "htw-text-gray-500": !unref(isActive) && !unref(variant).iconColor,
                  "bind-icon-color": !unref(isActive) && unref(variant).iconColor
                }])
              }, null, 8, ["icon", "class"]),
              createBaseVNode("span", _hoisted_2$5, toDisplayString(unref(variant).title), 1)
            ]),
            _: 1
          }, 8, ["to", "class"])), [
            [_directive_tooltip, unref(variant).title]
          ]),
          createBaseVNode("div", _hoisted_3$4, [
            createVNode(unref(f0), {
              content: () => unref(getSourceCode)(__props.story, unref(variant))
            }, null, 8, ["content"]),
            createVNode(_sfc_main$d, {
              variant: unref(variant),
              story: __props.story
            }, null, 8, ["variant", "story"])
          ])
        ]),
        createBaseVNode("div", {
          class: normalizeClass(["htw-border htw-bg-white dark:htw-bg-gray-700 htw-rounded htw-flex-1 htw-p-4 htw-relative", {
            "htw-border-gray-100 dark:htw-border-gray-800": !unref(isActive),
            "htw-border-primary-200 dark:htw-border-primary-900": unref(isActive)
          }]),
          "data-test-id": "sandbox-render",
          onClick: _cache[0] || (_cache[0] = withModifiers(($event) => selectVariant(), ["stop"])),
          onKeyup: _cache[1] || (_cache[1] = ($event) => selectVariant())
        }, [
          _cache[2] || (_cache[2] = createBaseVNode("div", {
            class: "htw-absolute htw-inset-0 htw-rounded bind-preview-bg",
            "data-test-id": "responsive-preview-bg"
          }, null, -1)),
          unref(settings).checkerboard ? (openBlock(), createBlock(CheckerboardPattern, {
            key: 0,
            class: "htw-absolute htw-inset-0 htw-w-full htw-h-full htw-text-gray-500/20"
          })) : createCommentVNode("", true),
          createBaseVNode("div", {
            class: "htw-relative htw-h-full",
            style: normalizeStyle({
              "--histoire-contrast-color": contrastColor.value,
              "color": autoApplyContrastColor.value ? contrastColor.value : void 0
            })
          }, [
            (openBlock(), createBlock(_sfc_main$z, {
              key: `${__props.story.id}-${unref(variant).id}`,
              variant: unref(variant),
              story: __props.story,
              dir: unref(settings).textDirection,
              class: normalizeClass({
                [unref(histoireConfig).theme.darkClass]: unref(isDark)
              }),
              onReady
            }, null, 8, ["variant", "story", "dir", "class"]))
          ], 4)
        ], 34)
      ], 512);
    };
  }
});
const StoryVariantGridItem = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-feff9239"]]);
const _hoisted_1$a = { class: "histoire-story-variant-grid htw-flex htw-flex-col htw-items-stretch htw-h-full __histoire-pane-shadow-from-right" };
const _hoisted_2$4 = {
  key: 0,
  class: "htw-flex-none htw-flex htw-items-center htw-justify-end htw-h-8 htw-mx-2 htw-mt-1"
};
const _hoisted_3$3 = { class: "htw-flex htw-w-0 htw-flex-1 htw-mx-4" };
const margin = 16;
const gap = 16;
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "StoryVariantGrid",
  setup(__props) {
    const storyStore = useStoryStore();
    const gridTemplateWidth = computed(() => {
      if (storyStore.currentStory.layout.type !== "grid") {
        return;
      }
      const layoutWidth = storyStore.currentStory.layout.width;
      if (!layoutWidth) {
        return "200px";
      }
      if (typeof layoutWidth === "number") {
        return `${layoutWidth}px`;
      }
      return layoutWidth;
    });
    const itemWidth = ref(16);
    const maxItemHeight = ref(0);
    const maxCount = ref(10);
    const countPerRow = ref(0);
    const visibleRows = ref(0);
    const el = ref(null);
    useResizeObserver(el, () => {
      updateMaxCount();
      updateSize();
    });
    function updateMaxCount() {
      if (!maxItemHeight.value) return;
      const width = el.value.clientWidth - margin * 2;
      const height = el.value.clientHeight;
      const scrollTop = el.value.scrollTop;
      countPerRow.value = Math.floor((width + gap) / (itemWidth.value + gap));
      visibleRows.value = Math.ceil((height + scrollTop + gap) / (maxItemHeight.value + gap));
      const newMaxCount = countPerRow.value * visibleRows.value;
      if (maxCount.value < newMaxCount) {
        maxCount.value = newMaxCount;
      }
      if (storyStore.currentVariant) {
        const index = storyStore.currentStory.variants.indexOf(storyStore.currentVariant);
        if (index + 1 > maxCount.value) {
          maxCount.value = index + 1;
        }
      }
    }
    function onItemResize(w, h2) {
      itemWidth.value = w;
      if (maxItemHeight.value < h2) {
        maxItemHeight.value = h2;
        updateMaxCount();
      }
    }
    watch(() => storyStore.currentVariant, () => {
      maxItemHeight.value = 0;
      updateMaxCount();
    });
    const gridEl = ref(null);
    const gridColumnWidth = ref(1);
    const viewWidth = ref(1);
    function updateSize() {
      if (!el.value) return;
      viewWidth.value = el.value.clientWidth;
      if (!gridEl.value) return;
      if (gridTemplateWidth.value.endsWith("%")) {
        gridColumnWidth.value = viewWidth.value * Number.parseInt(gridTemplateWidth.value) / 100 - gap;
      } else {
        gridColumnWidth.value = Number.parseInt(gridTemplateWidth.value);
      }
    }
    onMounted(() => {
      updateSize();
    });
    useResizeObserver(gridEl, () => {
      updateSize();
    });
    const columnCount = computed(() => Math.min(storyStore.currentStory.variants.length, Math.floor((viewWidth.value + gap) / (gridColumnWidth.value + gap))));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$a, [
        !unref(isMobile) ? (openBlock(), createElementBlock("div", _hoisted_2$4, [
          createVNode(ToolbarBackground),
          createVNode(_sfc_main$f),
          createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", {
          ref_key: "el",
          ref: el,
          class: "htw-overflow-y-auto htw-flex htw-flex-1",
          onScroll: _cache[0] || (_cache[0] = ($event) => updateMaxCount())
        }, [
          createBaseVNode("div", _hoisted_3$3, [
            createBaseVNode("div", {
              class: "htw-m-auto",
              style: normalizeStyle({
                minHeight: `${unref(storyStore).currentStory.variants.length / countPerRow.value * (maxItemHeight.value + gap) - gap}px`
              })
            }, [
              createBaseVNode("div", {
                ref_key: "gridEl",
                ref: gridEl,
                class: "htw-grid htw-gap-4 htw-my-4",
                style: normalizeStyle({
                  gridTemplateColumns: `repeat(${columnCount.value}, ${gridColumnWidth.value}px)`
                })
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(storyStore).currentStory.variants.slice(0, maxCount.value), (variant, index) => {
                  return openBlock(), createBlock(StoryVariantGridItem, {
                    key: index,
                    variant,
                    story: unref(storyStore).currentStory,
                    onResize: onItemResize
                  }, null, 8, ["variant", "story"]);
                }), 128))
              ], 4)
            ], 4)
          ])
        ], 544)
      ]);
    };
  }
});
const _hoisted_1$9 = { class: "htw-truncate" };
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "StoryVariantListItem",
  props: {
    variant: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "ab2181a2": unref(variant).iconColor
    }));
    const props = __props;
    const { variant } = toRefs(props);
    const { isActive, targetRoute } = useCurrentVariantRoute(variant);
    const el = ref();
    useScrollOnActive(isActive, el);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "el",
        ref: el,
        class: "histoire-story-variant-list-item",
        "data-test-id": "story-variant-list-item"
      }, [
        createVNode(BaseListItemLink, {
          to: unref(targetRoute),
          "is-active": unref(isActive),
          class: "htw-px-2 htw-py-2 md:htw-py-1.5 htw-m-1 htw-rounded-sm htw-flex htw-items-center htw-gap-2"
        }, {
          default: withCtx(({ active }) => [
            createVNode(unref(Icon), {
              icon: unref(variant).icon ?? "carbon:cube",
              class: normalizeClass(["htw-w-5 htw-h-5 sm:htw-w-4 sm:htw-h-4 htw-flex-none", {
                "htw-text-gray-500": !active && !unref(variant).iconColor,
                "bind-icon-color": !active && unref(variant).iconColor
              }])
            }, null, 8, ["icon", "class"]),
            createBaseVNode("span", _hoisted_1$9, toDisplayString(unref(variant).title), 1)
          ]),
          _: 1
        }, 8, ["to", "is-active"])
      ], 512);
    };
  }
});
const StoryVariantListItem = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-1b279b85"]]);
const _hoisted_1$8 = { class: "htw-flex htw-flex-col htw-items-stretch" };
const _hoisted_2$3 = { class: "htw-flex htw-items-center htw-gap-2 htw-px-4 htw-py-3" };
const _hoisted_3$2 = ["onClick"];
const _hoisted_4$2 = { class: "htw-ml-auto htw-opacity-70 htw-flex htw-gap-1" };
const _hoisted_5$2 = { key: 0 };
const _hoisted_6 = { key: 0 };
const _hoisted_7 = { key: 1 };
const _hoisted_8 = { key: 2 };
const _hoisted_9 = { key: 0 };
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "ToolbarResponsiveSize",
  setup(__props) {
    const settings = usePreviewSettingsStore().currentSettings;
    return (_ctx, _cache) => {
      const _component_VDropdown = resolveComponent("VDropdown");
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createBlock(_component_VDropdown, {
        placement: "bottom-end",
        skidding: 6,
        disabled: !unref(histoireConfig).responsivePresets?.length,
        class: "histoire-toolbar-responsive-size htw-h-full htw-flex-none"
      }, {
        popper: withCtx(({ hide }) => [
          createBaseVNode("div", _hoisted_1$8, [
            createVNode(_sfc_main$h, {
              modelValue: unref(settings).rotate,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(settings).rotate = $event)
            }, {
              default: withCtx(() => [..._cache[3] || (_cache[3] = [
                createTextVNode(" Rotate ", -1)
              ])]),
              _: 1
            }, 8, ["modelValue"]),
            createBaseVNode("div", _hoisted_2$3, [
              withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(settings).responsiveWidth = $event),
                type: "number",
                class: "htw-bg-transparent htw-border htw-border-gray-200 dark:htw-border-gray-850 htw-rounded htw-w-20 htw-opacity-50 focus:htw-opacity-100 htw-flex-1 htw-min-w-0",
                step: "16",
                placeholder: "Auto"
              }, null, 512), [
                [
                  vModelText,
                  unref(settings).responsiveWidth,
                  void 0,
                  { number: true }
                ],
                [_directive_tooltip, "Responsive width (px)"]
              ]),
              _cache[4] || (_cache[4] = createBaseVNode("span", { class: "htw-opacity-50" }, "", -1)),
              withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(settings).responsiveHeight = $event),
                type: "number",
                class: "htw-bg-transparent htw-border htw-border-gray-200 dark:htw-border-gray-850 htw-rounded htw-w-20 htw-opacity-50 focus:htw-opacity-100 htw-flex-1 htw-min-w-0",
                step: "16",
                placeholder: "Auto"
              }, null, 512), [
                [
                  vModelText,
                  unref(settings).responsiveHeight,
                  void 0,
                  { number: true }
                ],
                [_directive_tooltip, "Responsive height (px)"]
              ])
            ]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(histoireConfig).responsivePresets, (preset, index) => {
              return openBlock(), createElementBlock("button", {
                key: index,
                class: normalizeClass(["htw-px-4 htw-py-3 htw-cursor-pointer htw-text-left htw-flex htw-gap-4", [
                  unref(settings).responsiveWidth === preset.width && unref(settings).responsiveHeight === preset.height ? "htw-bg-primary-500 hover:htw-bg-primary-600 htw-text-white dark:htw-text-black" : "htw-bg-transparent hover:htw-bg-primary-100 dark:hover:htw-bg-primary-700"
                ]]),
                onClick: ($event) => {
                  unref(settings).responsiveWidth = preset.width;
                  unref(settings).responsiveHeight = preset.height;
                  hide();
                }
              }, [
                createTextVNode(toDisplayString(preset.label) + " ", 1),
                createBaseVNode("span", _hoisted_4$2, [
                  preset.width ? (openBlock(), createElementBlock("span", _hoisted_5$2, [
                    createTextVNode(toDisplayString(preset.width), 1),
                    !preset.height ? (openBlock(), createElementBlock("span", _hoisted_6, "px")) : createCommentVNode("", true)
                  ])) : createCommentVNode("", true),
                  preset.width && preset.height ? (openBlock(), createElementBlock("span", _hoisted_7, "x")) : createCommentVNode("", true),
                  preset.height ? (openBlock(), createElementBlock("span", _hoisted_8, [
                    createTextVNode(toDisplayString(preset.height), 1),
                    !preset.width ? (openBlock(), createElementBlock("span", _hoisted_9, "px")) : createCommentVNode("", true)
                  ])) : createCommentVNode("", true)
                ])
              ], 10, _hoisted_3$2);
            }), 128))
          ])
        ]),
        default: withCtx(() => [
          withDirectives((openBlock(), createElementBlock("div", {
            class: normalizeClass(["htw-flex htw-items-center htw-gap-1 htw-h-full htw-px-2 htw-group", {
              "htw-cursor-pointer hover:htw-text-primary-500": unref(histoireConfig).responsivePresets?.length
            }])
          }, [
            createVNode(unref(Icon), {
              icon: "carbon:devices",
              class: "htw-w-4 htw-h-4 htw-opacity-50 group-hover:htw-opacity-100"
            }),
            createVNode(unref(Icon), {
              icon: "carbon:caret-down",
              class: "htw-w-4 htw-h-4 htw-opacity-50 group-hover:htw-opacity-100"
            })
          ], 2)), [
            [_directive_tooltip, "Responsive sizes"]
          ])
        ]),
        _: 1
      }, 8, ["disabled"]);
    };
  }
});
const _hoisted_1$7 = { class: "histoire-toolbar-title htw-flex htw-items-center htw-gap-1 htw-text-gray-500 htw-flex-1 htw-truncate htw-min-w-0" };
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "ToolbarTitle",
  props: {
    variant: {}
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$7, [
        createVNode(unref(Icon), {
          icon: __props.variant.icon ?? "carbon:cube",
          class: normalizeClass(["htw-w-4 htw-h-4 htw-opacity-50", [
            __props.variant.iconColor ? "bind-icon-color" : "htw-text-gray-500"
          ]])
        }, null, 8, ["icon", "class"]),
        createBaseVNode("span", null, toDisplayString(__props.variant.title), 1)
      ]);
    };
  }
});
const _sfc_main$7 = {};
const _hoisted_1$6 = { class: "__histoire-hatched-pattern" };
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", _hoisted_1$6);
}
const HatchedPattern = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render], ["__scopeId", "data-v-91561117"]]);
const _hoisted_1$5 = { class: "histoire-story-responsive-preview htw-w-full htw-h-full htw-flex-1 htw-rounded-lg htw-relative htw-overflow-hidden" };
const _hoisted_2$2 = {
  key: 0,
  class: "htw-absolute htw-inset-0 htw-w-full htw-h-full htw-bg-gray-100 dark:htw-bg-gray-750 htw-rounded-r-lg htw-border-l-2 htw-border-gray-500/10 dark:htw-border-gray-700/30 htw-overflow-hidden"
};
const _hoisted_3$1 = {
  class: "bind-preview-bg htw-rounded-lg htw-h-full",
  "data-test-id": "responsive-preview-bg"
};
const _hoisted_4$1 = { class: "htw-p-8 htw-h-full htw-relative" };
const _hoisted_5$1 = { class: "htw-w-full htw-h-full htw-relative" };
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "StoryResponsivePreview",
  props: {
    variant: {}
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "v5f6f4ee9": unref(settings).backgroundColor
    }));
    const props = __props;
    const settings = usePreviewSettingsStore().currentSettings;
    const resizing = ref(false);
    const onUnmountedCleanupFns = [];
    onUnmounted(() => {
      onUnmountedCleanupFns.forEach((fn) => fn());
    });
    function addWindowListener(event, listener) {
      window.addEventListener(event, listener);
      const removeListener = () => window.removeEventListener(event, listener);
      onUnmountedCleanupFns.push(removeListener);
      return () => {
        removeListener();
        onUnmountedCleanupFns.splice(onUnmountedCleanupFns.indexOf(removeListener), 1);
      };
    }
    function useDragger(el, value, min, max, axis) {
      function onMouseDown(event) {
        event.preventDefault();
        event.stopPropagation();
        const start = axis === "x" ? event.clientX : event.clientY;
        const startValue = value.value ?? (axis === "x" ? previewWrapper.value.clientWidth - 67 : previewWrapper.value.clientHeight - 70);
        resizing.value = true;
        const removeListeners = [
          addWindowListener("mousemove", onMouseMove),
          addWindowListener("mouseup", onMouseUp)
        ];
        function onMouseMove(event2) {
          const snapTarget = axis === "x" ? previewWrapper.value.clientWidth : previewWrapper.value.clientHeight;
          const delta = (axis === "x" ? event2.clientX : event2.clientY) - start;
          value.value = Math.max(min, Math.min(max, startValue + delta));
          if (Math.abs(value.value - (snapTarget - 67)) < 16) {
            value.value = null;
          }
        }
        function onMouseUp() {
          removeListeners.forEach((fn) => fn());
          resizing.value = false;
        }
      }
      useEventListener(el, "mousedown", onMouseDown);
      function onTouchStart(event) {
        event.preventDefault();
        event.stopPropagation();
        const start = axis === "x" ? event.touches[0].clientX : event.touches[0].clientY;
        const startValue = value.value;
        resizing.value = true;
        const removeListeners = [
          addWindowListener("touchmove", onTouchMove),
          addWindowListener("touchend", onTouchEnd),
          addWindowListener("touchcancel", onTouchEnd)
        ];
        function onTouchMove(event2) {
          const delta = (axis === "x" ? event2.touches[0].clientX : event2.touches[0].clientY) - start;
          value.value = Math.max(min, Math.min(max, startValue + delta));
        }
        function onTouchEnd() {
          removeListeners.forEach((fn) => fn());
          resizing.value = false;
        }
      }
      useEventListener(el, "touchstart", onTouchStart);
    }
    const responsiveWidth = computed({
      get: () => settings[settings.rotate ? "responsiveHeight" : "responsiveWidth"],
      set: (value) => {
        settings[settings.rotate ? "responsiveHeight" : "responsiveWidth"] = value;
      }
    });
    const responsiveHeight = computed({
      get: () => settings[settings.rotate ? "responsiveWidth" : "responsiveHeight"],
      set: (value) => {
        settings[settings.rotate ? "responsiveWidth" : "responsiveHeight"] = value;
      }
    });
    const horizontalDragger = ref();
    const verticalDragger = ref();
    const cornerDragger = ref();
    const previewWrapper = ref();
    useDragger(horizontalDragger, responsiveWidth, 32, 2e4, "x");
    useDragger(verticalDragger, responsiveHeight, 32, 2e4, "y");
    useDragger(cornerDragger, responsiveWidth, 32, 2e4, "x");
    useDragger(cornerDragger, responsiveHeight, 32, 2e4, "y");
    const finalWidth = computed(() => settings.rotate ? settings.responsiveHeight : settings.responsiveWidth);
    const finalHeight = computed(() => settings.rotate ? settings.responsiveWidth : settings.responsiveHeight);
    const isResponsiveEnabled = computed(() => !props.variant.responsiveDisabled);
    const sizeTooltip = computed(() => `${responsiveWidth.value ?? "Auto"}  ${responsiveHeight.value ?? "Auto"}`);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$5, [
        isResponsiveEnabled.value ? (openBlock(), createElementBlock("div", _hoisted_2$2, [
          createVNode(HatchedPattern, { class: "htw-w-full htw-h-full htw-text-black/[1%] dark:htw-text-white/[1%]" })
        ])) : createCommentVNode("", true),
        createBaseVNode("div", {
          ref_key: "previewWrapper",
          ref: previewWrapper,
          class: "htw-h-full htw-overflow-auto htw-relative"
        }, [
          createBaseVNode("div", {
            class: normalizeClass(["htw-overflow-hidden htw-bg-white dark:htw-bg-gray-700 htw-rounded-lg htw-relative", isResponsiveEnabled.value ? {
              "htw-w-fit": !!finalWidth.value,
              "htw-h-fit": !!finalHeight.value,
              "htw-h-full": !finalHeight.value
            } : "htw-h-full"])
          }, [
            createBaseVNode("div", _hoisted_3$1, [
              unref(settings).checkerboard ? (openBlock(), createBlock(CheckerboardPattern, {
                key: 0,
                class: "htw-absolute htw-inset-0 htw-w-full htw-h-full htw-text-gray-500/20"
              })) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_4$1, [
                createBaseVNode("div", _hoisted_5$1, [
                  _cache[0] || (_cache[0] = createBaseVNode("div", { class: "htw-absolute htw-inset-0" }, null, -1)),
                  renderSlot(_ctx.$slots, "default", {
                    isResponsiveEnabled: isResponsiveEnabled.value,
                    finalWidth: finalWidth.value,
                    finalHeight: finalHeight.value,
                    resizing: resizing.value
                  }, void 0, true)
                ]),
                _cache[1] || (_cache[1] = createStaticVNode('<div class="htw-absolute htw-top-5 htw-left-8 htw-h-2 htw-w-px htw-bg-gray-400/25" data-v-18122333></div><div class="htw-absolute htw-top-5 htw-right-8 htw-h-2 htw-w-px htw-bg-gray-400/25" data-v-18122333></div><div class="htw-absolute htw-bottom-5 htw-left-8 htw-h-2 htw-w-px htw-bg-gray-400/25" data-v-18122333></div><div class="htw-absolute htw-bottom-5 htw-right-8 htw-h-2 htw-w-px htw-bg-gray-400/25" data-v-18122333></div><div class="htw-absolute htw-left-5 htw-top-8 htw-w-2 htw-h-px htw-bg-gray-400/25" data-v-18122333></div><div class="htw-absolute htw-left-5 htw-bottom-8 htw-w-2 htw-h-px htw-bg-gray-400/25" data-v-18122333></div><div class="htw-absolute htw-right-5 htw-top-8 htw-w-2 htw-h-px htw-bg-gray-400/25" data-v-18122333></div><div class="htw-absolute htw-right-5 htw-bottom-8 htw-w-2 htw-h-px htw-bg-gray-400/25" data-v-18122333></div>', 8))
              ]),
              isResponsiveEnabled.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                withDirectives((openBlock(), createElementBlock("div", {
                  ref_key: "horizontalDragger",
                  ref: horizontalDragger,
                  class: "htw-absolute htw-w-4 htw-top-0 htw-bottom-4 htw-right-0 hover:htw-bg-primary-500/30 htw-flex htw-items-center htw-justify-center htw-cursor-ew-resize htw-group hover:htw-text-primary-500"
                }, [
                  createVNode(unref(Icon), {
                    icon: "mdi:drag-vertical-variant",
                    class: "htw-w-4 htw-h-4 htw-opacity-20 group-hover:htw-opacity-90"
                  })
                ])), [
                  [
                    unref(Ot),
                    sizeTooltip.value,
                    void 0,
                    { right: true }
                  ]
                ]),
                withDirectives((openBlock(), createElementBlock("div", {
                  ref_key: "verticalDragger",
                  ref: verticalDragger,
                  class: "htw-absolute htw-h-4 htw-left-0 htw-right-4 htw-bottom-0 hover:htw-bg-primary-500/30 htw-flex htw-items-center htw-justify-center htw-cursor-ns-resize htw-group hover:htw-text-primary-500"
                }, [
                  createVNode(unref(Icon), {
                    icon: "mdi:drag-horizontal-variant",
                    class: "htw-w-4 htw-h-4 htw-opacity-20 group-hover:htw-opacity-90"
                  })
                ])), [
                  [
                    unref(Ot),
                    sizeTooltip.value,
                    void 0,
                    { bottom: true }
                  ]
                ]),
                withDirectives(createBaseVNode("div", {
                  ref_key: "cornerDragger",
                  ref: cornerDragger,
                  class: "htw-absolute htw-w-4 htw-h-4 htw-right-0 htw-bottom-0 hover:htw-bg-primary-500/30 htw-flex htw-items-center htw-justify-center htw-cursor-nwse-resize htw-group hover:htw-text-primary-500"
                }, null, 512), [
                  [
                    unref(Ot),
                    sizeTooltip.value,
                    void 0,
                    { bottom: true }
                  ]
                ])
              ], 64)) : createCommentVNode("", true)
            ])
          ], 2)
        ], 512)
      ]);
    };
  }
});
const StoryResponsivePreview = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-18122333"]]);
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "StoryVariantSinglePreviewNative",
  props: {
    story: {},
    variant: {}
  },
  setup(__props) {
    const props = __props;
    Object.assign(props.variant, {
      previewReady: false
    });
    function onReady() {
      Object.assign(props.variant, {
        previewReady: true
      });
    }
    const settings = usePreviewSettingsStore().currentSettings;
    const contrastColor = computed(() => getContrastColor(settings));
    const autoApplyContrastColor = computed(() => !!histoireConfig.autoApplyContrastColor);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(StoryResponsivePreview, {
        class: "histoire-story-variant-single-preview-native",
        variant: __props.variant
      }, {
        default: withCtx(({ isResponsiveEnabled, finalWidth, finalHeight }) => [
          createBaseVNode("div", {
            style: normalizeStyle([
              isResponsiveEnabled ? {
                width: finalWidth ? `${finalWidth}px` : "100%",
                height: finalHeight ? `${finalHeight}px` : "100%"
              } : { width: "100%", height: "100%" },
              {
                "--histoire-contrast-color": contrastColor.value,
                "color": autoApplyContrastColor.value ? contrastColor.value : void 0
              }
            ]),
            class: "htw-relative",
            "data-test-id": "sandbox-render"
          }, [
            (openBlock(), createBlock(_sfc_main$z, {
              key: `${__props.story.id}-${__props.variant.id}`,
              variant: __props.variant,
              story: __props.story,
              class: normalizeClass(["htw-h-full", {
                [unref(histoireConfig).sandboxDarkClass]: unref(isDark),
                // @TODO remove
                [unref(histoireConfig).theme.darkClass]: unref(isDark)
              }]),
              dir: unref(settings).textDirection,
              onReady
            }, null, 8, ["variant", "story", "class", "dir"]))
          ], 4)
        ]),
        _: 1
      }, 8, ["variant"]);
    };
  }
});
const _hoisted_1$4 = ["src"];
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "StoryVariantSinglePreviewRemote",
  props: {
    story: {},
    variant: {}
  },
  setup(__props) {
    const props = __props;
    const settings = usePreviewSettingsStore().currentSettings;
    const iframe = ref();
    function syncState() {
      if (iframe.value && props.variant.previewReady) {
        iframe.value.contentWindow.postMessage({
          type: STATE_SYNC,
          state: toRawDeep(props.variant.state, true)
        });
      }
    }
    let synced = false;
    watch(() => props.variant.state, () => {
      if (synced) {
        synced = false;
        return;
      }
      syncState();
    }, {
      deep: true,
      immediate: true
    });
    Object.assign(props.variant, {
      previewReady: false
    });
    useEventListener(window, "message", (event) => {
      switch (event.data.type) {
        case STATE_SYNC:
          updateVariantState(event.data.state);
          break;
        case EVENT_SEND:
          logEvent(event.data.event);
          break;
        case SANDBOX_READY:
          setPreviewReady();
          break;
      }
    });
    function updateVariantState(state) {
      synced = true;
      applyState(props.variant.state, state);
    }
    function logEvent(event) {
      const eventsStore = useEventsStore();
      eventsStore.addEvent(event);
    }
    function setPreviewReady() {
      Object.assign(props.variant, {
        previewReady: true
      });
    }
    const sandboxUrl = computed(() => {
      return getSandboxUrl(props.story, props.variant);
    });
    const isIframeLoaded = ref(false);
    watch(sandboxUrl, () => {
      isIframeLoaded.value = false;
      Object.assign(props.variant, {
        previewReady: false
      });
    });
    function syncSettings() {
      if (iframe.value) {
        iframe.value.contentWindow.postMessage({
          type: PREVIEW_SETTINGS_SYNC,
          settings: toRaw(settings)
        });
      }
    }
    watch(() => settings, () => {
      syncSettings();
    }, {
      deep: true,
      immediate: true
    });
    function onIframeLoad() {
      isIframeLoaded.value = true;
      syncState();
      syncSettings();
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(StoryResponsivePreview, {
        class: "histoire-story-variant-single-preview-remote",
        variant: __props.variant
      }, {
        default: withCtx(({ isResponsiveEnabled, finalWidth, finalHeight, resizing }) => [
          createBaseVNode("iframe", {
            ref_key: "iframe",
            ref: iframe,
            src: sandboxUrl.value,
            class: normalizeClass(["htw-w-full htw-h-full htw-relative", {
              "htw-invisible": !isIframeLoaded.value,
              "htw-pointer-events-none": resizing
            }]),
            style: normalizeStyle(isResponsiveEnabled ? {
              width: finalWidth ? `${finalWidth}px` : null,
              height: finalHeight ? `${finalHeight}px` : null
            } : void 0),
            "data-test-id": "preview-iframe",
            onLoad: _cache[0] || (_cache[0] = ($event) => onIframeLoad())
          }, null, 46, _hoisted_1$4)
        ]),
        _: 1
      }, 8, ["variant"]);
    };
  }
});
const _hoisted_1$3 = {
  class: "histoire-story-variant-single-view htw-h-full htw-flex htw-flex-col",
  "data-test-id": "story-variant-single-view"
};
const _hoisted_2$1 = {
  key: 0,
  class: "htw-flex-none htw-flex htw-items-center htw-h-8 -htw-mt-1"
};
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "StoryVariantSingleView",
  props: {
    variant: {},
    story: {}
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        !unref(isMobile) ? (openBlock(), createElementBlock("div", _hoisted_2$1, [
          createVNode(_sfc_main$8, { variant: __props.variant }, null, 8, ["variant"]),
          !__props.variant.responsiveDisabled ? (openBlock(), createBlock(_sfc_main$9, { key: 0 })) : createCommentVNode("", true),
          createVNode(ToolbarBackground),
          createVNode(_sfc_main$f),
          createVNode(_sfc_main$d, {
            variant: __props.variant,
            story: __props.story
          }, null, 8, ["variant", "story"]),
          createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        __props.story.layout?.iframe === false ? (openBlock(), createBlock(_sfc_main$5, {
          key: 1,
          story: __props.story,
          variant: __props.variant
        }, null, 8, ["story", "variant"])) : (openBlock(), createBlock(_sfc_main$4, {
          key: 2,
          story: __props.story,
          variant: __props.variant
        }, null, 8, ["story", "variant"]))
      ]);
    };
  }
});
const _hoisted_1$2 = {
  key: 0,
  class: "histoire-story-variant-single htw-p-2 htw-h-full __histoire-pane-shadow-from-right"
};
const _hoisted_2 = {
  key: 0,
  class: "htw-divide-y htw-divide-gray-100 dark:htw-divide-gray-800 htw-h-full htw-flex htw-flex-col"
};
const _hoisted_3 = {
  key: 0,
  class: "htw-p-2 htw-h-full"
};
const _hoisted_4 = { class: "htw-h-full htw-overflow-y-auto" };
const _hoisted_5 = {
  key: 0,
  class: "htw-p-2 htw-h-full __histoire-pane-shadow-from-right"
};
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "StoryVariantSingle",
  emits: {
    openVariantMenu: () => true
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "v41c4d268": variant.value?.iconColor
    }));
    const storyStore = useStoryStore();
    const hasSingleVariant = computed(() => storyStore.currentStory?.variants.length === 1);
    const variant = computed(() => storyStore.currentVariant);
    return (_ctx, _cache) => {
      return hasSingleVariant.value && variant.value ? (openBlock(), createElementBlock("div", _hoisted_1$2, [
        createVNode(_sfc_main$3, {
          variant: variant.value,
          story: unref(storyStore).currentStory
        }, null, 8, ["variant", "story"])
      ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        unref(isMobile) ? (openBlock(), createElementBlock("div", _hoisted_2, [
          createBaseVNode("a", {
            class: "htw-px-6 htw-h-12 hover:htw-text-primary-500 dark:hover:htw-text-primary-400 htw-cursor-pointer htw-flex htw-gap-2 htw-flex-wrap htw-w-full htw-items-center htw-flex-none",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("openVariantMenu"))
          }, [
            variant.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createVNode(unref(Icon), {
                icon: variant.value.icon ?? "carbon:cube",
                class: normalizeClass(["htw-w-5 htw-h-5 htw-flex-none", {
                  "htw-text-gray-500": !variant.value.iconColor,
                  "bind-icon-color": variant.value.iconColor
                }])
              }, null, 8, ["icon", "class"]),
              createTextVNode(" " + toDisplayString(variant.value.title), 1)
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(" Select a variant... ")
            ], 64)),
            createVNode(unref(Icon), {
              icon: "carbon:chevron-sort",
              class: "htw-w-5 htw-h-5 htw-shrink-0 htw-ml-auto"
            })
          ]),
          unref(storyStore).currentVariant ? (openBlock(), createElementBlock("div", _hoisted_3, [
            createVNode(_sfc_main$3, {
              variant: unref(storyStore).currentVariant,
              story: unref(storyStore).currentStory
            }, null, 8, ["variant", "story"])
          ])) : createCommentVNode("", true)
        ])) : (openBlock(), createBlock(BaseSplitPane, {
          key: 1,
          "save-id": "story-single-main-split",
          min: 5,
          max: 40,
          "default-split": 17
        }, {
          first: withCtx(() => [
            createBaseVNode("div", _hoisted_4, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(storyStore).currentStory.variants, (v, index) => {
                return openBlock(), createBlock(StoryVariantListItem, {
                  key: index,
                  variant: v
                }, null, 8, ["variant"]);
              }), 128))
            ])
          ]),
          last: withCtx(() => [
            unref(storyStore).currentVariant ? (openBlock(), createElementBlock("div", _hoisted_5, [
              createVNode(_sfc_main$3, {
                variant: unref(storyStore).currentVariant,
                story: unref(storyStore).currentStory
              }, null, 8, ["variant", "story"])
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        }))
      ], 64));
    };
  }
});
const StoryVariantSingle = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-c2a43485"]]);
const _hoisted_1$1 = { class: "histoire-story-viewer htw-bg-gray-50 htw-h-full dark:htw-bg-gray-750" };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "StoryViewer",
  setup(__props) {
    useCssVars((_ctx) => ({
      "v0f021d3c": variant.value?.iconColor
    }));
    const storyStore = useStoryStore();
    const variant = computed(() => storyStore.currentVariant);
    const isMenuOpened = ref(false);
    function closeMenu() {
      isMenuOpened.value = false;
    }
    watch(variant, () => {
      isMenuOpened.value = false;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", _hoisted_1$1, [
          unref(storyStore).currentStory.layout.type === "grid" ? (openBlock(), createBlock(_sfc_main$b, { key: 0 })) : unref(storyStore).currentStory.layout.type === "single" ? (openBlock(), createBlock(StoryVariantSingle, {
            key: 1,
            onOpenVariantMenu: _cache[0] || (_cache[0] = ($event) => isMenuOpened.value = true)
          })) : createCommentVNode("", true)
        ]),
        createVNode(_sfc_main$A, {
          title: "Select a variant",
          opened: isMenuOpened.value,
          onClose: closeMenu
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(storyStore).currentStory.variants, (v, index) => {
              return openBlock(), createBlock(StoryVariantListItem, {
                key: index,
                variant: v
              }, null, 8, ["variant"]);
            }), 128))
          ]),
          _: 1
        }, 8, ["opened"])
      ], 64);
    };
  }
});
const StoryViewer = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-096f6d6e"]]);
const _hoisted_1 = {
  key: 1,
  class: "histoire-story-view histoire-with-story htw-h-full"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "StoryView",
  setup(__props) {
    const storyStore = useStoryStore();
    const router = useRouter();
    const route = useRoute();
    watch(() => storyStore.currentVariant, (value) => {
      if (value) {
        storyStore.currentStory.lastSelectedVariant = value;
      }
    }, {
      immediate: true
    });
    watch(() => [storyStore.currentStory, storyStore.currentVariant], () => {
      if (!storyStore.currentVariant) {
        if (storyStore.currentStory?.lastSelectedVariant) {
          setVariant(storyStore.currentStory.lastSelectedVariant.id);
          return;
        }
        if (storyStore.currentStory?.variants.length === 1) {
          setVariant(storyStore.currentStory.variants[0].id);
        }
      }
    }, {
      immediate: true
    });
    function setVariant(variantId) {
      router.replace({
        ...route,
        query: {
          ...route.query,
          variantId
        }
      });
    }
    const docsOnlyScroller = ref(null);
    function scrollDocsToTop() {
      docsOnlyScroller.value?.scrollTo(0, 0);
    }
    return (_ctx, _cache) => {
      return !unref(storyStore).currentStory ? (openBlock(), createBlock(BaseEmpty, {
        key: 0,
        class: "histoire-story-view histoire-no-story"
      }, {
        default: withCtx(() => [
          createVNode(unref(Icon), {
            icon: "carbon:software-resource-resource",
            class: "htw-w-16 htw-h-16 htw-opacity-50"
          })
        ]),
        _: 1
      })) : (openBlock(), createElementBlock("div", _hoisted_1, [
        unref(storyStore).currentStory.docsOnly ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref_key: "docsOnlyScroller",
          ref: docsOnlyScroller,
          class: "htw-h-full htw-overflow-auto"
        }, [
          createVNode(_sfc_main$y, {
            story: unref(storyStore).currentStory,
            standalone: "",
            class: "md:htw-p-12 htw-w-full md:htw-max-w-[600px] lg:htw-max-w-[800px] xl:htw-max-w-[900px]",
            onScrollTop: _cache[0] || (_cache[0] = ($event) => scrollDocsToTop())
          }, null, 8, ["story"])
        ], 512)) : unref(isMobile) ? (openBlock(), createBlock(StoryViewer, { key: 1 })) : (openBlock(), createBlock(BaseSplitPane, {
          key: 2,
          "save-id": "story-main",
          min: 30,
          max: 95,
          "default-split": 75,
          class: "htw-h-full"
        }, {
          first: withCtx(() => [
            createVNode(StoryViewer)
          ]),
          last: withCtx(() => [
            createVNode(_sfc_main$i)
          ]),
          _: 1
        }))
      ]));
    };
  }
});
export {
  _sfc_main as default
};
